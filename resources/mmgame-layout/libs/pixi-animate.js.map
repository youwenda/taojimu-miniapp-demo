{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/animate/Animator.js","src/animate/AnimatorTimeline.js","src/animate/MovieClip.js","src/animate/Scene.js","src/animate/ShapesCache.js","src/animate/SymbolLoader.js","src/animate/Timeline.js","src/animate/Tween.js","src/animate/index.js","src/animate/load.js","src/animate/sound.js","src/animate/utils.js","src/mixins/Container.js","src/mixins/DisplayObject.js","src/mixins/Graphics.js","src/mixins/Sprite.js","src/mixins/Text.js","src/mixins/index.js","index.js"],"names":[],"mappings":";;;;;;;AAAA;;;;;ACAA;;;;;;;;AAEA;AACA,IAAM,YAAY,EAAlB;;AAEA;;;;;;IAKM;;;;;AAgCF;;;;;;;;;;;;aAYO,qBAAK,UAAU,OAAO,UAAU;AACnC,YAAI,OAAO,KAAX;AACA,YAAI,cAAJ;AAAA,YAAW,YAAX;AACA,YAAM,kBAAkB,OAAO,KAAP,KAAiB,UAAzC;AACA,YAAI,UAAU,SAAV,IAAuB,eAA3B,EAA4C;AACxC,oBAAQ,CAAR;AACA,kBAAM,SAAS,WAAT,GAAuB,CAA7B;AACA,gBAAI,eAAJ,EAAqB;AACjB,2BAAW,KAAX;AACH;AACJ,SAND,MAMO;AACH,oBAAQ,SAAS,SAAT,CAAmB,KAAnB,CAAR;AACA,kBAAM,SAAS,SAAT,CAAmB,QAAQ,KAAK,UAAhC,CAAN;AACA,gBAAI,QAAQ,SAAZ,EAAuB;AACnB,sBAAM,SAAS,SAAT,CAAmB,QAAQ,KAAK,UAAhC,CAAN;AACA,uBAAO,IAAP;AACH;AACD,gBAAI,UAAU,SAAd,EAAyB;AACrB,sBAAM,IAAI,KAAJ,CAAU,8BAA8B,KAA9B,GAAsC,GAAhD,CAAN;AACH,aAFD,MAEO,IAAI,QAAQ,SAAZ,EAAuB;AAC1B,sBAAM,IAAI,KAAJ,CAAU,4BAA4B,KAA5B,GAAoC,GAA9C,CAAN;AACH;AACJ;AACD,eAAO,KAAK,MAAL,CACH,QADG,EAEH,KAFG,EAGH,GAHG,EAIH,IAJG,EAKH,QALG,CAAP;AAOH;;AAED;;;;;;;;;;;aASO,iBAAG,UAAU,KAAK,UAAU;AAC/B,eAAO,KAAK,MAAL,CACH,QADG,EAEH,SAAS,YAFN,EAGH,GAHG,EAIH,KAJG,EAKH,QALG,CAAP;AAOH;;AAED;;;;;;;;;;;;;aAWO,yBAAO,UAAU,OAAO,KAAK,MAAM,UAAU;;AAEhD,YAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,gBAAM,aAAa,KAAnB;AACA,oBAAQ,SAAS,SAAT,CAAmB,UAAnB,CAAR;AACA,gBAAI,UAAU,SAAd,EAAyB;AACrB,sBAAM,IAAI,KAAJ,CAAU,8BAA8B,UAA9B,GAA2C,GAArD,CAAN;AACH;AACJ;AACD,YAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AACzB,gBAAM,WAAW,GAAjB;AACA,kBAAM,SAAS,SAAT,CAAmB,QAAnB,CAAN;AACA,gBAAI,QAAQ,SAAZ,EAAuB;AACnB,sBAAM,IAAI,KAAJ,CAAU,4BAA4B,QAA5B,GAAuC,GAAjD,CAAN;AACH;AACJ;AACD,YAAI,QAAQ,CAAZ,EAAe;AACX,kBAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACH;AACD,YAAI,OAAO,SAAS,WAApB,EAAiC;AAC7B,kBAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACH;AACD,YAAI,SAAS,GAAb,EAAkB;AACd,kBAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACH;;AAED;AACA,aAAK,IAAL,CAAU,QAAV;;AAEA,eAAO,CAAC,CAAC,IAAT;;AAEA;AACA,YAAM,WAAW,2BAAiB,MAAjB,CACb,QADa,EAEb,KAFa,EAGb,GAHa,EAIb,IAJa,EAKb,QALa,CAAjB;AAOA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,QAArB;;AAEA;AACA,YAAI,SAAS,YAAT,KAA0B,KAA9B,EAAqC;AACjC,qBAAS,WAAT,CAAqB,KAArB;AACH,SAFD,MAEO;AACH,qBAAS,IAAT;AACH;AACD,eAAO,QAAP;AACH;;AAED;;;;;;;;aAMO,qBAAK,UAAU;AAClB,aAAK,IAAI,IAAI,CAAR,EAAW,MAAM,KAAK,UAAL,CAAgB,MAAtC,EAA8C,IAAI,GAAlD,EAAuD,GAAvD,EAA4D;AACxD,gBAAM,WAAW,KAAK,UAAL,CAAgB,CAAhB,CAAjB;AACA,gBAAI,SAAS,QAAT,KAAsB,QAA1B,EAAoC;AAChC,qBAAK,aAAL,CAAmB,QAAnB;AACA;AACH;AACJ;AACJ;;AAED;;;;;;;aAKO,6BAAU;AACb,aAAK,IAAI,IAAI,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAAtC,EAAyC,KAAK,CAA9C,EAAiD,GAAjD,EAAsD;AAClD,iBAAK,aAAL,CAAmB,KAAK,UAAL,CAAgB,CAAhB,CAAnB;AACH;AACJ;;AAED;;;;;;;;;aAOO,uCAAc,UAAU;AAC3B,aAAK,UAAL,CAAgB,MAAhB,CAAuB,KAAK,UAAL,CAAgB,OAAhB,CAAwB,QAAxB,CAAvB,EAA0D,CAA1D;AACA,iBAAS,QAAT,CAAkB,IAAlB;AACA,iBAAS,OAAT;AACH;;;;;;AAhMD;;;;;;4BAMwB;AACpB,mBAAO,SAAP;AACH;;AAED;;;;;;;;;4BAMwB;AACpB,mBAAO,OAAP;AACH;;AAED;;;;;;;;;4BAMwB;AACpB,mBAAO,OAAP;AACH;;;;;;AAuKL,OAAO,OAAP,GAAiB,QAAjB;;;;;;;;;AC/MA,IAAM,OAAO,EAAb;;AAEA;;;;;;IAKM;AACF,gCAAc;AAAA;;AACV,aAAK,OAAL,GAAe,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAf;AACA,aAAK,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACH;;AAED;;;;;;;;;;;;+BAUA,qBAAK,UAAU,OAAO,KAAK,MAAM,UAAU;;AAEvC;;;;;;AAMA,aAAK,QAAL,GAAgB,QAAhB;;AAEA;;;;;;AAMA,aAAK,IAAL,GAAY,IAAZ;;AAEA;;;;;;AAMA,aAAK,KAAL,GAAa,KAAb;;AAEA;;;;;;AAMA,aAAK,GAAL,GAAW,GAAX;;AAEA;;;;;;AAMA,aAAK,QAAL,GAAgB,QAAhB;;AAEA,YAAI,QAAJ,EAAc;AACV,qBAAS,WAAT,CAAqB,KAArB;AACA,qBAAS,aAAT,GAAyB,KAAK,OAA9B;AACH;AACJ;;AAED;;;;;;;+BAKA,6BAAU;AACN,aAAK,QAAL,CAAc,aAAd,GAA8B,IAA9B;AACA,aAAK,IAAL,CAAU,IAAV,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAtB,EAA6B,IAA7B;AACA,yBAAiB,KAAjB,CAAuB,IAAvB,CAA4B,IAA5B;AACH;;AAED;;;;;;;;;+BAOA,yBAAO,UAAU;AACb,YAAI,kBAAJ;AACA,YAAI,SAAS,YAAT,IAAyB,KAAK,GAAlC,EAAuC;;AAEnC;AACA,qBAAS,YAAT,GAAwB,KAAK,GAA7B;;AAEA,gBAAI,KAAK,IAAT,EAAe;AACX;AACA,yBAAS,eAAT;AACA,yBAAS,WAAT,CAAqB,KAAK,KAA1B;AACH,aAJD,MAIO;AACH,yBAAS,IAAT;AACA,oBAAI,KAAK,QAAT,EAAmB;AACf,gCAAY,KAAK,QAAjB;AACH;AACD,qBAAK,IAAL,GALG,CAKU;AAChB;AACJ;AACD,eAAO,SAAP;AACH;;AAED;;;;;;+BAIA,uBAAO;AACH,aAAK,OAAL,CAAa,QAAb,CAAsB,aAAtB,CAAoC,IAApC;AACH;;AAED;;;;;;;;AAsBA;;;;;;;;;;;qBAWO,yBAAO,UAAU,OAAO,KAAK,MAAM,UAAU;AAChD,YAAI,QAAJ;AACA,YAAI,KAAK,KAAL,CAAW,MAAf,EAAuB;AACnB,uBAAW,KAAK,KAAL,CAAW,GAAX,EAAX;AACH,SAFD,MAEO;AACH,uBAAW,IAAI,gBAAJ,EAAX;AACH;AACD,iBAAS,IAAT,CAAc,QAAd,EAAwB,KAAxB,EAA+B,GAA/B,EAAoC,IAApC,EAA0C,QAA1C;AACA,eAAO,QAAP;AACH;;;;4BApCc;AACX,gBAAM,WAAW,CAAC,KAAK,QAAL,CAAc,YAAd,GAA6B,KAAK,KAAnC,KAA6C,KAAK,GAAL,GAAW,KAAK,KAA7D,CAAjB;AACA,mBAAO,KAAK,GAAL,CAAS,CAAT,EAAY,KAAK,GAAL,CAAS,CAAT,EAAY,QAAZ,CAAZ,CAAP,CAFW,CAEgC;AAC9C;;AAED;;;;;;;;;;4BAOmB;AACf,mBAAO,IAAP;AACH;;;;;;AAyBL,OAAO,OAAP,GAAiB,gBAAjB;;;;;;;;;ACpKA;;;;AACA;;;;;;;;;;;;AAEA,IAAM,YAAY,KAAK,SAAvB;AACA,IAAM,eAAe,KAAK,MAAL,CAAY,MAAjC;;AAEA;;;;;;;;;;;;;;;IAcM;;;AACF,uBAAY,OAAZ,EAAqB,QAArB,EAA+B,IAA/B,EAAqC,SAArC,EAAgD,MAAhD,EAAwD;AAAA;;AAGpD;AAHoD,qDACpD,qBADoD;;AAIpD,kBAAU,YAAY,SAAZ,GAAwB,EAAxB,GAA6B,OAAvC;;AAEA;AACA,YAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,sBAAU;AACN,sBAAM,WAAW,UAAU,WADrB;AAEN,0BAAU,YAAY,CAFhB;AAGN,sBAAM,SAAS,SAAT,GAAqB,IAArB,GAA4B,IAH5B;AAIN,wBAAQ,UAAU,EAJZ;AAKN,2BAAW,aAAa,CALlB;AAMN,+BAAe;AANT,aAAV;AAQH,SATD,MASO;AACH;AACA,sBAAU,OAAO,MAAP,CAAc;AACpB,sBAAM,UAAU,WADI;AAEpB,+BAAe,CAFK;AAGpB,sBAAM,IAHc;AAIpB,wBAAQ,EAJY;AAKpB,0BAAU,CALU;AAMpB,2BAAW;AANS,aAAd,EAOP,OAPO,CAAV;AAQH;;AAED;;;;;;;AAOA,cAAK,IAAL,GAAY,QAAQ,IAApB;;AAEA;;;;;;AAMA,cAAK,aAAL,GAAqB,QAAQ,aAA7B;;AAEA;;;;;;AAMA,cAAK,IAAL,GAAY,CAAC,CAAC,QAAQ,IAAtB;;AAEA;;;;;;;AAOA,cAAK,YAAL,GAAoB,CAApB;;AAEA;;;;;;AAMA,cAAK,OAAL,GAAe,EAAf;;AAEA;;;;;;AAMA,cAAK,UAAL,GAAkB,QAAQ,MAA1B;AACA,YAAI,QAAQ,MAAZ,EAAoB;AAChB,iBAAK,IAAI,IAAT,IAAiB,QAAQ,MAAzB,EAAiC;AAC7B,oBAAI,QAAQ;AACR,2BAAO,IADC;AAER,8BAAU,QAAQ,MAAR,CAAe,IAAf;AAFF,iBAAZ;AAIA,sBAAK,OAAL,CAAa,IAAb,CAAkB,KAAlB;AACH;AACD,kBAAK,OAAL,CAAa,IAAb,CAAkB,UAAS,CAAT,EAAY,CAAZ,EAAe;AAC7B,uBAAO,EAAE,QAAF,GAAa,EAAE,QAAtB;AACH,aAFD;AAGH;;AAED;;;;;;AAMA,cAAK,WAAL,GAAmB,IAAnB;;AAEA;;;;;;AAMA,cAAK,MAAL,GAAc,KAAd;;AAEA;;;;;;AAMA,cAAK,cAAL,GAAsB,IAAtB;;AAEA;;;;;;;;;;;;AAYA,cAAK,SAAL,GAAiB,IAAjB;;AAEA;;;;;;AAMA,cAAK,YAAL,GAAoB,CAApB;;AAEA;;;;;;AAMA,cAAK,QAAL,GAAgB,CAAC,CAAjB,CA9IoD,CA8IhC;;AAEpB;;;;;;;;AAQA,cAAK,EAAL,GAAU,CAAV;;AAEA;;;;;;;;;;AAUA,cAAK,UAAL,GAAkB,QAAQ,SAA1B;;AAEA;;;;;;;AAOA,cAAK,SAAL,GAAiB,CAAjB;;AAEA;;;;;;;AAOA,cAAK,YAAL,GAAoB,QAAQ,QAA5B;;AAEA;;;;;;;AAOA,cAAK,UAAL,GAAkB,EAAlB;;AAEA;;;;;;;;AAQA,cAAK,oBAAL,GAA4B,EAA5B;;AAEA;;;;;;AAMA,cAAK,YAAL,GAAoB,EAApB;;AAEA;;;;;;AAMA,cAAK,QAAL,GAAgB,EAAhB;;AAEA;;;;;;;AAOA,cAAK,aAAL,GAAqB,IAArB;;AAEA,YAAI,MAAK,IAAL,KAAc,UAAU,WAA5B,EAAyC;AACrC,kBAAK,aAAL,GAAqB,MAAK,aAAL,CAAmB,IAAnB,OAArB;AACA,kBAAK,QAAL,GAAgB,MAAK,QAAL,CAAc,IAAd,OAAhB;AACA,kBAAK,UAAL,GAAkB,MAAK,UAAL,CAAgB,IAAhB,OAAlB;AACA,kBAAK,EAAL,CAAQ,OAAR,EAAiB,MAAK,QAAtB;AACA,kBAAK,EAAL,CAAQ,SAAR,EAAmB,MAAK,UAAxB;AACH;;AAED,YAAI,QAAQ,SAAZ,EAAuB;AACnB,kBAAK,SAAL,GAAiB,QAAQ,SAAzB;AACH;;AAED;AACA;AACA,cAAK,OAAL,GAAe,MAAK,OAApB;AACA,cAAK,eAAL,GAAuB,MAAK,eAA5B;AACA,cAAK,oBAAL,GAA4B,MAAK,oBAAjC;AACA,cAAK,KAAL,GAAa,MAAK,KAAlB;AArPoD;AAsPvD;;wBAED,+BAAW;AACP,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;AACD,qBAAa,GAAb,CAAiB,KAAK,aAAtB;AACH;;wBAED,uCAAc,iBAAiB;AAC3B,YAAI,KAAK,MAAL,IAAe,CAAC,KAAK,WAAzB,EAAsC;AAClC;AACA,gBAAI,KAAK,QAAL,GAAgB,CAApB,EAAuB;AACnB,qBAAK,KAAL,CAAW,KAAK,YAAhB;AACH;AACD;AACH;AACD,YAAI,UAAU,kBAAkB,aAAa,KAA/B,GAAuC,KAAK,QAAL,CAAc,WAArD,GAAmE,IAAjF;AACA,aAAK,OAAL,CAAa,OAAb;AACH;;wBAED,mCAAa;AACT,qBAAa,MAAb,CAAoB,KAAK,aAAzB;AACH;;AAED;;;;;;;;AA6FA;;;;;;wBAMA,mCAAY,UAAU;AAClB,YAAI,KAAK,YAAL,GAAoB,QAAxB,EAAkC;AAC9B,iBAAK,YAAL,GAAoB,QAApB;AACH;AACJ;;AAED;;;;;;;;wBAMA,6CAAiB,YAAY;AACzB;AACA,YAAI,OAAO,WAAW,CAAlB,KAAwB,QAA5B,EAAsC;AAClC,uBAAW,CAAX,GAAe,gBAAM,SAAN,CAAgB,WAAW,CAA3B,CAAf;AACH,SAFD,MAEO,IAAI,OAAO,WAAW,CAAlB,KAAwB,QAA5B,EAAsC;AACzC,uBAAW,CAAX,GAAe,CAAC,CAAC,WAAW,CAA5B;AACH;AACJ;;AAED;;;;;;;;;wBAOA,+CAAkB,UAAU;AACxB,aAAK,IAAI,IAAI,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAAtC,EAAyC,KAAK,CAA9C,EAAiD,EAAE,CAAnD,EAAsD;AAClD,gBAAI,KAAK,UAAL,CAAgB,CAAhB,EAAmB,MAAnB,KAA8B,QAAlC,EAA4C;AACxC,uBAAO,KAAK,UAAL,CAAgB,CAAhB,CAAP;AACH;AACJ;AACD,YAAI,WAAW,uBAAa,QAAb,CAAf;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,QAArB;AACA,eAAO,QAAP;AACH;;AAED;;;;;;;;;wBAOA,qCAAa,UAAU,WAAW;AAC9B,aAAK,IAAI,CAAT,IAAc,SAAd,EAAyB;AACrB,iBAAK,WAAL,CAAiB,QAAjB,EAA2B;AACvB,mBAAG,UAAU,CAAV;AADoB,aAA3B,EAEG,SAAS,CAAT,EAAY,EAAZ,CAFH;AAGH;;AAED;AACA,aAAK,oBAAL,CAA0B,KAAK,YAA/B,EAA6C,KAAK,YAAlD,EAAgE,IAAhE;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;;;wBAOA,iBAAG,UAAU,WAAW;AACpB,eAAO,KAAK,YAAL,CAAkB,QAAlB,EAA4B,SAA5B,CAAP;AACH;;AAED;;;;;;;;;;;;;wBAWA,6BAAS,UAAU,YAAY,YAAY,UAAU,MAAM;;AAEvD,YAAI,WAAW,KAAK,iBAAL,CAAuB,QAAvB,CAAf;AACA,aAAK,gBAAL,CAAsB,UAAtB;AACA,iBAAS,QAAT,CAAkB,UAAlB,EAA8B,UAA9B,EAA0C,QAA1C,EAAoD,IAApD;AACA,aAAK,WAAL,CAAiB,aAAa,QAA9B;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;;;;;;;wBAWA,mCAAY,UAAU,YAAY,YAAY;;AAE1C,YAAI,WAAW,KAAK,iBAAL,CAAuB,QAAvB,CAAf;AACA,aAAK,gBAAL,CAAsB,UAAtB;AACA,iBAAS,WAAT,CAAqB,UAArB,EAAiC,UAAjC;AACA,aAAK,WAAL,CAAiB,UAAjB;AACA,eAAO,IAAP;AACH;;AAED;;;;;;;wBAKA,iBAAG,UAAU,YAAY,UAAU,WAAW;AAC1C,eAAO,KAAK,aAAL,CAAmB,QAAnB,EAA6B,UAA7B,EAAyC,QAAzC,EAAmD,SAAnD,CAAP;AACH;;AAED;;;;;;;;;;;wBASA,uCAAc,UAAU,YAAY,UAAU,WAAW;;AAErD,YAAI,eAAe,SAAnB,EAA8B;AAC9B;AACI,6BAAa,CAAb;AACH;AACD,YAAI,aAAa,SAAb,IAA0B,WAAW,CAAzC,EAA4C;AAC5C;AACI,2BAAW,KAAK,YAAL,IAAqB,CAAhC;AACH;;AAED;AACA,YAAI,SAAS,IAAT,KAAkB,UAAU,OAAhC,EAAyC;AACrC,qBAAS,mBAAT,GAA+B,UAA/B;AACH;;AAED;AACA;AACA;AACA,YAAI,iBAAJ;AAAA,YAAc,UAAd;AACA;AACA,aAAK,IAAI,KAAK,oBAAL,CAA0B,MAA1B,GAAmC,CAA5C,EAA+C,KAAK,CAApD,EAAuD,EAAE,CAAzD,EAA4D;AACxD,gBAAI,KAAK,oBAAL,CAA0B,CAA1B,EAA6B,MAA7B,KAAwC,QAA5C,EAAsD;AAClD,2BAAW,KAAK,oBAAL,CAA0B,CAA1B,CAAX;AACA;AACH;AACJ;AACD;AACA,YAAI,CAAC,QAAL,EAAe;AACX,uBAAW,EAAX;AACA,qBAAS,MAAT,GAAkB,QAAlB;AACA,iBAAK,oBAAL,CAA0B,IAA1B,CAA+B,QAA/B;AACH;;AAED;AACA,wBAAM,UAAN,CAAiB,QAAjB,EAA2B,UAA3B,EAAuC,QAAvC;;AAEA;AACA;AACA,YAAI,KAAK,YAAL,GAAoB,aAAa,QAArC,EAA+C;AAC3C,iBAAK,YAAL,GAAoB,aAAa,QAAjC;AACH;;AAED;AACA,YAAI,SAAJ,EAAe;AACX,gBAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,4BAAY,gBAAM,oBAAN,CAA2B,SAA3B,CAAZ;AACH;AACD;AACA;AACA,gBAAI,YAAY,EAAhB;AACA,iBAAK,IAAI,EAAT,IAAc,SAAd,EAAyB;AACrB,4BAAY,OAAO,MAAP,CAAc,EAAd,EAAkB,SAAlB,EAA6B,UAAU,EAAV,CAA7B,CAAZ;AACA,qBAAK,WAAL,CAAiB,QAAjB,EAA2B,SAA3B,EAAsC,SAAS,EAAT,EAAY,EAAZ,CAAtC;AACH;AACD,iBAAK,iBAAL,CAAuB,QAAvB,EACK,eADL,CACqB,aAAa,QADlC;AAEH;;AAED;AACA,aAAK,oBAAL,CAA0B,UAA1B,EAAsC,KAAK,YAA3C,EAAyD,IAAzD;;AAEA,eAAO,IAAP;AACH;;AAED;;;;;;;;;wBAOA,iBAAG,UAAU,YAAY;AACrB,eAAO,KAAK,SAAL,CAAe,QAAf,EAAyB,UAAzB,CAAP;AACH;;AAED;;;;;;;;;wBAOA,+BAAU,UAAU,YAAY;;AAE5B,YAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAChC,gBAAM,QAAQ,KAAK,UAAL,CAAgB,UAAhB,CAAd;AACA,gBAAI,UAAU,SAAd,EAAyB;AACrB,uCAAoB,UAApB;AACH;AACD,yBAAa,KAAb;AACH;;AAED,YAAI,UAAU,KAAK,QAAnB;AACA;AACA,YAAI,QAAQ,MAAR,IAAkB,UAAtB,EAAkC;AAC9B,oBAAQ,MAAR,GAAiB,aAAa,CAA9B;AACH;AACD,YAAI,KAAK,YAAL,GAAoB,UAAxB,EAAoC;AAChC,iBAAK,YAAL,GAAoB,UAApB;AACH;AACD;AACA,YAAI,QAAQ,UAAR,CAAJ,EAAyB;AACrB,oBAAQ,UAAR,EAAoB,IAApB,CAAyB,QAAzB;AACH,SAFD,MAEO;AACH,oBAAQ,UAAR,IAAsB,CAAC,QAAD,CAAtB;AACH;AACD,eAAO,IAAP;AACH;;AAED;;;;;;;;;;wBAQA,iBAAG,OAAO,MAAM;AACZ,eAAO,KAAK,SAAL,CAAe,KAAf,EAAsB,IAAtB,CAAP;AACH;;AAED;;;;;;;;;;wBAQA,+BAAU,OAAO,MAAM;AACnB,aAAK,OAAL,CAAa,KAAb,CAAmB,IAAnB,CAAwB,MAAxB,EAAgC,KAAhC,EAAuC,CAAC,CAAC,IAAzC,EAA+C,IAA/C;AACA,eAAO,IAAP;AACH;;AAED;;;;;;wBAIA,uBAAO;AACH,aAAK,MAAL,GAAc,KAAd;AACH;;AAED;;;;;;wBAIA,uBAAO;AACH,aAAK,MAAL,GAAc,IAAd;AACH;;AAED;;;;;;;wBAKA,mCAAY,iBAAiB;AACzB,aAAK,MAAL,GAAc,KAAd;AACA,aAAK,KAAL,CAAW,eAAX;AACH;;AAED;;;;;;;wBAKA,mCAAY,iBAAiB;AACzB,aAAK,MAAL,GAAc,IAAd;AACA,aAAK,KAAL,CAAW,eAAX;AACH;;AAED;;;;;;;;AAiBA;;;;;wBAKA,2BAAQ,MAAM;;AAEV;AACA;AACA,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;;AAED,YAAI,IAAJ,EAAU;AACN,iBAAK,EAAL,IAAW,IAAX;AACH;AACD,YAAI,KAAK,EAAL,GAAU,KAAK,SAAnB,EAA8B;AAC1B,iBAAK,EAAL,GAAU,KAAK,IAAL,GAAY,KAAK,EAAL,GAAU,KAAK,SAA3B,GAAuC,KAAK,SAAtD;AACH;AACD;AACA,aAAK,YAAL,GAAoB,KAAK,KAAL,CAAW,KAAK,EAAL,GAAU,KAAK,UAAf,GAA4B,UAAvC,CAApB;AACA;AACA,YAAI,KAAK,YAAL,IAAqB,KAAK,YAA9B,EAA4C;AACxC,iBAAK,YAAL,GAAoB,KAAK,YAAL,GAAoB,CAAxC;AACH;AACD,YAAI,wBAAJ;AACA,YAAI,KAAK,aAAT,EAAwB;AACpB,8BAAkB,KAAK,aAAL,CAAmB,IAAnB,CAAlB;AACH;AACD;AACA,aAAK,eAAL;;AAEA;AACA,YAAI,eAAJ,EAAqB;AACjB;AACH;AACJ;;AAED;;;;;;;wBAKA,uBAAM,iBAAiB;AACnB,YAAI,MAAM,OAAO,eAAP,KAA2B,QAA3B,GAAsC,KAAK,UAAL,CAAgB,eAAhB,CAAtC,GAAyE,eAAnF;AACA,YAAI,QAAQ,SAAZ,EAAuB;AACvB;AACI;AACH;AACD;AACA,aAAK,QAAL,GAAgB,GAAhB;AACA,aAAK,YAAL,GAAoB,GAApB;;AAEA;AACA;AACA,YAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,iBAAK,SAAL,GAAiB,KAAK,eAAtB;AACH;;AAED;AACA,YAAI,KAAK,UAAL,GAAkB,CAAtB,EAAyB;AACrB,iBAAK,EAAL,GAAU,MAAM,KAAK,UAArB;AACH,SAFD,MAEO;AACH,iBAAK,EAAL,GAAU,CAAV;AACH;AACD,aAAK,eAAL;AACH;;AAED;;;;;;wBAIA,2BAAS;AACL,aAAK,QAAL,GAAgB,CAAC,CAAjB;AACA,aAAK,EAAL,GAAU,CAAV;AACA,aAAK,YAAL,GAAoB,CAApB;AACH;;AAED;;;;;;wBAIA,6CAAkB;AACd,YAAI,UAAU,KAAK,IAAL,KAAc,UAAU,WAAtC;;AAEA,YAAI,OAAJ,EAAa;AACT,iBAAK,YAAL,GAAoB,KAAK,aAAL,IAAsB,KAAK,IAAL,KAAc,UAAU,YAAxB,GAAuC,CAAvC,GAA2C,KAAK,YAAtE,CAApB;AACA,gBAAI,KAAK,YAAL,IAAqB,KAAK,YAA9B,EAA4C;AACxC,qBAAK,YAAL,IAAqB,KAAK,YAA1B;AACH;AACJ;;AAED,YAAI,KAAK,QAAL,KAAkB,KAAK,YAA3B,EAAyC;AACrC;AACH;;AAED;AACA,aAAK,oBAAL,CAA0B,KAAK,QAA/B,EAAyC,KAAK,YAA9C,EAA4D,UAAU,KAAV,GAAkB,KAAK,cAAnF;;AAEA,aAAK,QAAL,GAAgB,KAAK,YAArB;AACH;;AAED;;;;;;;;;;wBAQA,qDAAqB,YAAY,cAAc,WAAW;AACtD;AACA,YAAI,UAAJ;AAAA,YAAO,UAAP;AAAA,YAAU,eAAV;AAAA,YAAkB,aAAa,KAAK,UAApC;AACA,aAAK,IAAI,WAAW,MAAX,GAAoB,CAA7B,EAAgC,KAAK,CAArC,EAAwC,EAAE,CAA1C,EAA6C;AACzC,gBAAI,WAAW,WAAW,CAAX,CAAf;AACA,iBAAK,IAAI,CAAJ,EAAO,SAAS,SAAS,MAA9B,EAAsC,IAAI,MAA1C,EAAkD,EAAE,CAApD,EAAuD;AACnD,oBAAI,QAAQ,SAAS,CAAT,CAAZ;AACA;AACA,oBAAI,gBAAgB,MAAM,UAAtB,IACA,gBAAgB,MAAM,QAD1B,EACoC;AAChC;AACA;AACA,0BAAM,WAAN,CAAkB,YAAlB;AACA;AACH;AACJ;AACJ;;AAED,YAAI,sBAAsB,KAAK,oBAA/B;AACA,YAAI,cAAc,KAAK,YAAvB;AACA,aAAK,IAAI,CAAJ,EAAO,SAAS,oBAAoB,MAAzC,EAAiD,IAAI,MAArD,EAA6D,EAAE,CAA/D,EAAkE;AAC9D,gBAAI,SAAS,oBAAoB,CAApB,EAAuB,MAApC;AACA,gBAAI,gBAAgB,oBAAoB,CAApB,EAAuB,YAAvB,CAApB;AACA;AACA,gBAAI,aAAJ,EAAmB;AACf;AACA;AACA,4BAAY,IAAZ,CAAiB,MAAjB;AACA,oBAAI,OAAO,MAAP,KAAkB,IAAtB,EAA4B;AACxB;AACA,yBAAK,QAAL,CAAc,MAAd;AACA,wBAAI,OAAO,IAAP,KAAgB,UAAU,WAA1B,IAAyC,OAAO,SAApD,EAA+D;AAC3D,+BAAO,MAAP;AACH;AACJ;AACJ,aAXD,MAWO,IAAI,CAAC,aAAD,IAAkB,OAAO,MAAP,KAAkB,IAAxC,EAA8C;AACjD,qBAAK,WAAL,CAAiB,MAAjB;AACH;AACJ;;AAED;AACA,aAAK,IAAI,CAAJ,EAAO,SAAS,YAAY,MAAjC,EAAyC,IAAI,MAA7C,EAAqD,GAArD,EAA0D;AACtD,gBAAI,UAAS,YAAY,CAAZ,CAAb;AACA,gBAAI,eAAe,KAAK,QAAL,CAAc,OAAd,CAAsB,OAAtB,CAAnB;AACA,gBAAI,iBAAiB,CAArB,EAAwB;AACpB,qBAAK,UAAL,CAAgB,OAAhB,EAAwB,CAAxB;AACH;AACJ;;AAED;AACA,oBAAY,MAAZ,GAAqB,CAArB;;AAEA;AACA,YAAI,WAAW,KAAK,QAApB;AAAA,YACI,cADJ;AAEA,aAAK,IAAI,CAAJ,EAAO,SAAS,SAAS,MAA9B,EAAsC,IAAI,MAA1C,EAAkD,EAAE,CAApD,EAAuD;AACnD,oBAAQ,SAAS,CAAT,CAAR;AACA,gBAAI,MAAM,IAAN,KAAe,UAAU,OAA7B,EAAsC;AAClC,sBAAM,YAAN,GAAqB,eAAe,MAAM,mBAA1C;AACA,sBAAM,eAAN;AACH;AACJ;;AAED;AACA,YAAI,SAAJ,EAAe;AACX,gBAAI,UAAU,KAAK,QAAnB;AACA;AACA,gBAAI,YAAY,KAAhB;AACA,gBAAI,eAAe,UAAnB,EAA+B;AAC3B,yBAAS,QAAQ,MAAjB;AACA,4BAAY,IAAZ;AACH,aAHD,MAGO;AACH,yBAAS,KAAK,GAAL,CAAS,eAAe,CAAxB,EAA2B,QAAQ,MAAnC,CAAT;AACH;AACD,iBAAK,IAAI,cAAc,CAAd,GAAkB,aAAa,CAA/B,GAAmC,YAA5C,EAA0D,IAAI,MAA9D,EAAsE,EAAE,CAAxE,EAA2E;AACvE,oBAAI,QAAQ,CAAR,CAAJ,EAAgB;AACZ,wBAAI,eAAe,QAAQ,CAAR,CAAnB;AACA,yBAAK,IAAI,CAAT,EAAY,IAAI,aAAa,MAA7B,EAAqC,EAAE,CAAvC,EAA0C;AACtC,qCAAa,CAAb,EAAgB,IAAhB,CAAqB,IAArB;AACH;AACJ;AACD;AACA,oBAAI,aAAa,MAAM,SAAS,CAAhC,EAAmC;AAC/B,wBAAI,CAAJ;AACA,6BAAS,eAAe,CAAxB;AACA,gCAAY,KAAZ;AACH;AACJ;AACJ;AACJ;;wBAED,2BAAQ,iBAAiB;AACrB,YAAI,KAAK,aAAT,EAAwB;AACpB,yBAAa,MAAb,CAAoB,KAAK,aAAzB;AACA,iBAAK,aAAL,GAAqB,IAArB;AACH;AACD,YAAM,iBAAiB,EAAvB;AACA,YAAI,YAAY,KAAK,UAArB;AACA,YAAI,SAAJ,EAAe;AACX,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAAU,MAA9B,EAAsC,GAAtC,EAA2C;AACvC,oBAAM,WAAW,UAAU,CAAV,CAAjB;AACA,+BAAe,IAAf,CAAoB,SAAS,MAA7B;AACA,yBAAS,aAAT,GAAyB,IAAzB;AACA,yBAAS,MAAT,GAAkB,CAAlB;AACH;AACJ;AACD,oBAAY,KAAK,oBAAjB;AACA,YAAI,SAAJ,EAAe;AACX,iBAAK,IAAI,MAAI,CAAb,EAAgB,MAAI,UAAU,MAA9B,EAAsC,KAAtC,EAA2C;AACvC,oBAAM,YAAW,UAAU,GAAV,CAAjB;AACA,oBAAI,eAAe,OAAf,CAAuB,UAAS,MAAhC,IAA0C,CAA9C,EAAiD;AAC7C,mCAAe,IAAf,CAAoB,UAAS,MAA7B;AACH;AACD,0BAAS,aAAT,GAAyB,IAAzB;AACA,0BAAS,MAAT,GAAkB,CAAlB;AACH;AACJ;AACD;AACA,aAAK,IAAI,MAAI,CAAb,EAAgB,MAAI,eAAe,MAAnC,EAA2C,KAA3C,EAAgD;AAC5C;AACA,gBAAI,KAAK,QAAL,CAAc,OAAd,CAAsB,eAAe,GAAf,CAAtB,IAA2C,CAA/C,EAAkD;AAC9C,+BAAe,GAAf,EAAkB,OAAlB,CAA0B,eAA1B;AACH;AACJ;AACD,uBAAe,MAAf,GAAwB,CAAxB;AACA,aAAK,QAAL,GAAgB,IAAhB;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,aAAK,YAAL,GAAoB,IAApB;AACA,aAAK,oBAAL,GAA4B,IAA5B;AACA,aAAK,aAAL,GAAqB,IAArB;AACA,aAAK,OAAL,GAAe,IAAf;AACA,aAAK,UAAL,GAAkB,IAAlB;AACA,6BAAM,OAAN,YAAc,eAAd;AACH;;;;4BA3oBY;AACT,mBAAO,KAAK,OAAZ;AACH;;AAED;;;;;;;;;4BAMgB;AACZ,mBAAO,KAAK,UAAZ;AACH;;AAED;;;;;;;;;4BAMmB;AACf,gBAAI,SAAS,KAAK,OAAlB;AACA,gBAAI,UAAU,IAAd;AACA,iBAAK,IAAI,IAAI,CAAR,EAAW,MAAM,OAAO,MAA7B,EAAqC,IAAI,GAAzC,EAA8C,EAAE,CAAhD,EAAmD;AAC/C,oBAAI,OAAO,CAAP,EAAU,QAAV,IAAsB,KAAK,YAA/B,EAA6C;AACzC,8BAAU,OAAO,CAAP,EAAU,KAApB;AACH,iBAFD,MAEO;AACH;AACH;AACJ;AACD,mBAAO,OAAP;AACH;;AAED;;;;;;;;;;4BAOkB;AACd,mBAAO,KAAK,EAAZ;AACH;0BAEe,OAAO;AACnB,iBAAK,EAAL,GAAU,KAAV;AACH;;AAED;;;;;;;;;;;;;;;;;;4BAegB;AACZ,mBAAO,KAAK,UAAZ;AACH;0BACa,OAAO;AACjB,gBAAI,QAAQ,CAAZ,EAAe;AACX,qBAAK,UAAL,GAAkB,KAAlB;AACA,qBAAK,SAAL,GAAiB,QAAQ,KAAK,YAAL,GAAoB,KAA5B,GAAoC,CAArD;AACA,qBAAK,EAAL,GAAU,KAAK,YAAL,GAAoB,KAA9B;AACH,aAJD,MAIO;AACH,qBAAK,EAAL,GAAU,KAAK,UAAL,GAAkB,KAAK,SAAL,GAAiB,CAA7C;AACH;AACJ;;AAED;;;;;;;;;;4BAOkB;AACd,mBAAO,KAAK,YAAZ;AACH;;;4BAwTqB;AAClB,gBAAI,IAAI,IAAR;AAAA,gBACI,MAAM,EAAE,UADZ;AAEA,mBAAO,CAAC,IAAI,EAAE,MAAP,KAAkB,CAAC,GAA1B,EAA+B;AAC3B,oBAAI,EAAE,IAAF,KAAW,UAAU,WAAzB,EAAsC;AAClC,0BAAM,EAAE,UAAR;AACH;AACJ;AACD,mBAAO,OAAO,UAAU,iBAAxB;AACH;;;;EA5qBmB;;AAo6BxB;;;;;;;;;;;AASA,UAAU,WAAV,GAAwB,CAAxB;;AAEA;;;;;;;;AAQA,UAAU,YAAV,GAAyB,CAAzB;;AAEA;;;;;;;;;AASA,UAAU,OAAV,GAAoB,CAApB;;AAGA;;;;;;;;AAQA,UAAU,iBAAV,GAA8B,EAA9B;;AAEA;;;;;;;AAOA;;;;;;;AAOA,UAAU,MAAV,GAAmB,UAAU,CAAV,GAAc,UAAS,KAAT,EAAgB;AAC7C,UAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,UAAU,SAAxB,CAAlB;AACA,UAAM,SAAN,CAAgB,QAAhB,GAA2B,UAAU,SAArC;AACA,UAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,WAAO,KAAP;AACH,CALD;;AAOA;kBACe;;;;;;;ACz/Bf;;;;AACA;;;;;;;;;;;;AAEA;;;;;;;;;;;;;IAaM;;;AAEL,gBAAY,KAAZ,EAAmB,MAAnB,EAA2B,aAA3B,EAA0C,OAA1C,EAAmD;AAAA;;AAGlD;;;;;;AAHkD,+CAClD,6BAAM,KAAN,EAAa,MAAb,EAAqB,aAArB,EAAoC,OAApC,CADkD;;AASlD,QAAK,KAAL;;AAEA;;;;;;AAMA,QAAK,QAAL,GAAgB,IAAhB;AAjBkD;AAkBlD;;AAED;;;;;;;;;;iBAQA,qBAAK,UAAU,UAAU,UAAU;AAAA;;AAClC,SAAO,oBAAK,QAAL,EAAe,KAAK,KAApB,EAA2B,UAAC,QAAD,EAAc;AAC/C,UAAK,QAAL,GAAgB,QAAhB;AACA,OAAI,QAAJ,EAAc;AACb,aAAS,QAAT;AACA;AACD,GALM,EAKJ,QALI,CAAP;AAMA;;AAED;;;;;;;iBAKA,2BAAQ,YAAY;AACnB,MAAI,KAAK,QAAT,EAAmB;AAClB,QAAK,QAAL,CAAc,OAAd,CAAsB,IAAtB;AACA,QAAK,QAAL,GAAgB,IAAhB;AACA;AACD,8BAAM,OAAN,YAAc,UAAd;AACA;;;EAlDkB,KAAK;;kBAqDV;;;;;;;;;ACrEf;;;;;;AAEA;;;;;AAKA,IAAM,cAAc,EAApB;;AAEA;;;;;;;AAOA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,KAAnC,EAA0C;AACtC,gBAAY,KAD0B;AAEtC,WAAO,eAAS,IAAT,EAAe,KAAf,EAAsB;;AAEzB;AACA,YAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,oBAAQ,gBAAM,iBAAN,CAAwB,KAAxB,CAAR;AACH;;AAED;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACnC,gBAAI,OAAO,MAAM,CAAN,CAAX;AACA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AAClC,oBAAI,MAAM,KAAK,CAAL,CAAV;AACA,oBAAI,OAAO,GAAP,KAAe,QAAf,IAA2B,IAAI,CAAJ,MAAW,GAA1C,EAA+C;AAC3C,yBAAK,CAAL,IAAU,gBAAM,SAAN,CAAgB,GAAhB,CAAV;AACH;AACJ;AACJ;AACD,oBAAY,IAAZ,IAAoB,KAApB;AACH;AApBqC,CAA1C;;AAwBA;;;;;;;AAOA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,WAAnC,EAAgD;AAC5C,gBAAY,KADgC;AAE5C,WAAO,eAAS,EAAT,EAAa;AAChB,eAAO,YAAY,EAAZ,KAAmB,IAA1B;AACH;AAJ2C,CAAhD;;AAOA;;;;;;AAMA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,QAAnC,EAA6C;AACzC,gBAAY,KAD6B;AAEzC,WAAO,eAAS,EAAT,EAAa;AAChB,YAAI,QAAO,EAAP,yCAAO,EAAP,OAAc,QAAlB,EAA4B;AACxB,iBAAK,IAAI,IAAT,IAAiB,EAAjB,EAAqB;AACjB,4BAAY,MAAZ,CAAmB,IAAnB;AACH;AACD;AACH;AACD,YAAI,YAAY,EAAZ,CAAJ,EAAqB;AACjB,wBAAY,EAAZ,EAAgB,MAAhB,GAAyB,CAAzB;AACA,mBAAO,YAAY,EAAZ,CAAP;AACH;AACJ;AAbwC,CAA7C;;AAgBA;;;;;AAKA,OAAO,cAAP,CAAsB,WAAtB,EAAmC,WAAnC,EAAgD;AAC5C,gBAAY,KADgC;AAE5C,WAAO,iBAAW;AACd,aAAK,IAAI,EAAT,IAAe,WAAf,EAA4B;AACxB,wBAAY,MAAZ,CAAmB,EAAnB;AACH;AACJ;AAN2C,CAAhD;;AASA;kBACe;;;;;;;AC3Ff;;;;;;AAEA;;;;;;;AAOA,IAAI,eAAe,SAAf,YAAe,GAAW;AAC1B,WAAO,UAAS,QAAT,EAAmB,IAAnB,EAAyB;AAC5B,YAAI,MAAM,SAAS,GAAnB;AACA,YAAI,OAAO,SAAS,IAApB;;AAEA,YAAI,IAAI,MAAJ,CAAW,wBAAX,IAAuC,CAAC,CAA5C,EAA+C;AAC3C,kCAAY,GAAZ,CAAgB,SAAS,IAAzB,EAA+B,IAA/B;AACH,SAFD,MAEO,IAAI,KAAK,QAAL,IAAiB,KAAK,QAAL,KAAkB,KAAvC,EAA8C;AACjD;AACA;AACA,iBAAK,OAAL,CAAa,iBAAb,CACI,KAAK,OAAL,CAAa,SAAb,CAAuB,GAAvB,CADJ,EAEI,SAAS,IAFb;AAIH;AACD;AACH,KAfD;AAgBH,CAjBD;;AAmBA;AACA,KAAK,OAAL,CAAa,MAAb,CAAoB,iBAApB,CAAsC,YAAtC;;kBAEe;;;;;;;AC/Bf;;;;;;AAEA;;;;;;;;AAQA,IAAM,WAAW,SAAX,QAAW,CAAS,MAAT,EAAiB;AAC9B,UAAM,IAAN,CAAW,IAAX;;AAEA;;;;;AAKA,SAAK,MAAL,GAAc,MAAd;;AAEA;;;;;;;AAOA,SAAK,aAAL,GAAqB,EAArB;AACH,CAlBD;;AAoBA,IAAM,IAAI,SAAS,SAAT,GAAqB,OAAO,MAAP,CAAc,MAAM,SAApB,CAA/B;;AAEA;;;;;;;AAOA,EAAE,QAAF,GAAa,UAAS,UAAT,EAAqB,UAArB,EAAiC,QAAjC,EAA2C,IAA3C,EAAiD;AAC1D,SAAK,eAAL,CAAqB,aAAa,CAAlC;AACA;AACA,QAAI,aAAa,EAAjB;AACA,QAAI,aAAJ;AACA;AACA,SAAK,IAAL,IAAa,UAAb,EAAyB;AACrB;AACA,YAAI,KAAK,aAAL,CAAmB,cAAnB,CAAkC,IAAlC,CAAJ,EAA6C;AACzC,uBAAW,IAAX,IAAmB,KAAK,aAAL,CAAmB,IAAnB,CAAnB;AACH;AACD;AAHA,aAIK;AACD,oBAAI,aAAa,WAAW,IAAX,IAAmB,KAAK,oBAAL,CAA0B,IAA1B,CAApC;AACA;AACA;AACA;AACA,qBAAK,IAAI,IAAI,KAAK,MAAL,GAAc,CAA3B,EAA8B,KAAK,CAAnC,EAAsC,EAAE,CAAxC,EAA2C;AACvC,yBAAK,CAAL,EAAQ,UAAR,CAAmB,IAAnB,IAA2B,UAA3B;AACA,yBAAK,CAAL,EAAQ,QAAR,CAAiB,IAAjB,IAAyB,UAAzB;AACH;AACJ;AACJ;AACD;AACA,QAAI,QAAQ,oBAAU,KAAK,MAAf,EAAuB,UAAvB,EAAmC,UAAnC,EAA+C,UAA/C,EAA2D,QAA3D,EAAqE,IAArE,CAAZ;AACA,SAAK,IAAL,CAAU,KAAV;AACA;AACA;AACA,WAAO,MAAP,CAAc,KAAK,aAAnB,EAAkC,MAAM,QAAxC;AACH,CA7BD;;AA+BA;;;;;;AAMA,EAAE,WAAF,GAAgB,UAAS,UAAT,EAAqB,UAArB,EAAiC;AAC7C,SAAK,eAAL,CAAqB,aAAa,CAAlC;AACA,QAAI,aAAa,OAAO,MAAP,CAAc,EAAd,EAAkB,KAAK,aAAvB,EAAsC,UAAtC,CAAjB;AACA;AACA,QAAI,QAAQ,oBAAU,KAAK,MAAf,EAAuB,UAAvB,EAAmC,IAAnC,EAAyC,UAAzC,EAAqD,CAArD,CAAZ;AACA,SAAK,IAAL,CAAU,KAAV;AACA,WAAO,MAAP,CAAc,KAAK,aAAnB,EAAkC,MAAM,QAAxC;AACH,CAPD;;AASA;;;;;AAKA,EAAE,eAAF,GAAoB,UAAS,QAAT,EAAmB;AACnC,QAAI,KAAK,MAAT,EAAiB;AACb,YAAI,YAAY,KAAK,KAAK,MAAL,GAAc,CAAnB,CAAhB;AACA,YAAI,UAAU,QAAV,GAAqB,QAAzB,EAAmC;AAC/B,gBAAI,UAAU,gBAAd,EAAgC;AAC5B,0BAAU,QAAV,GAAqB,QAArB;AACH,aAFD,MAEO;AACH,qBAAK,WAAL,CACI,KAAK,aADT,EAEI,UAAU,QAAV,GAAqB,CAFzB,EAGI,WAAW,UAAU,QAArB,GAAgC,CAHpC;AAKH;AACJ;AACJ;AACJ,CAfD;;AAiBA;;;;;AAKA,EAAE,oBAAF,GAAyB,UAAS,IAAT,EAAe;AACpC,QAAM,SAAS,KAAK,MAApB;AACA,YAAQ,IAAR;AACI,aAAK,GAAL;AACI,mBAAO,OAAO,QAAP,CAAgB,CAAvB;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,QAAP,CAAgB,CAAvB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,KAAP,CAAa,CAApB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,KAAP,CAAa,CAApB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,IAAP,CAAY,CAAnB;AACJ,aAAK,IAAL;AACI,mBAAO,OAAO,IAAP,CAAY,CAAnB;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,QAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,KAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,OAAd;AACJ,aAAK,GAAL;AACI,mBAAO,OAAO,IAAd;AACA;AACA;AACA;AACA;AAxBR;AA0BA,WAAO,IAAP;AACH,CA7BD;;AA+BA;kBACe;;;;;;;;;AChJf;;;;;;;;;;;;IAYM;AAEF,mBAAY,MAAZ,EAAoB,UAApB,EAAgC,QAAhC,EAA0C,UAA1C,EAAsD,QAAtD,EAAgE,IAAhE,EAAsE;AAAA;;AAElE;;;;;AAKA,aAAK,MAAL,GAAc,MAAd;;AAEA;;;;;AAKA,aAAK,UAAL,GAAkB,UAAlB;;AAEA;;;;;;AAMA,aAAK,QAAL,GAAgB,EAAhB;;AAEA;;;;;AAKA,aAAK,QAAL,GAAgB,QAAhB;;AAEA;;;;;AAKA,aAAK,UAAL,GAAkB,UAAlB;;AAEA;;;;;AAKA,aAAK,QAAL,GAAgB,aAAa,QAA7B;;AAEA;;;;;AAKA,aAAK,IAAL,GAAY,IAAZ;;AAEA;;;;;AAKA,aAAK,gBAAL,GAAwB,CAAC,QAAzB;;AAGA,YAAI,aAAJ;AACA,YAAI,QAAJ,EAAc;AACV;AACA,iBAAK,IAAL,IAAa,QAAb,EAAuB;AACnB,qBAAK,QAAL,CAAc,IAAd,IAAsB,SAAS,IAAT,CAAtB;AACH;AACJ;;AAED;AACA,aAAK,IAAL,IAAa,UAAb,EAAyB;AACrB,gBAAI,CAAC,KAAK,QAAL,CAAc,cAAd,CAA6B,IAA7B,CAAL,EAAyC;AACrC,qBAAK,QAAL,CAAc,IAAd,IAAsB,WAAW,IAAX,CAAtB;AACH;AACJ;AACJ;;AAED;;;;;;;oBAKA,mCAAY,cAAc;AACtB;AACA;AACA,YAAI,gBAAgB,KAAK,QAAzB,EAAmC;AAC/B,iBAAK,QAAL;AACA;AACH;;AAED,YAAI,KAAK,gBAAT,EAA2B;AACvB,iBAAK,QAAL;AACA;AACH;;AAED,YAAI,OAAO,CAAC,eAAe,KAAK,UAArB,IAAmC,KAAK,QAAnD;AACA,YAAI,KAAK,IAAT,EAAe;AACX,mBAAO,KAAK,IAAL,CAAU,IAAV,CAAP;AACH;AACD,YAAI,SAAS,KAAK,MAAlB;AACA,YAAI,aAAa,KAAK,UAAtB;AACA,YAAI,WAAW,KAAK,QAApB;AACA,aAAK,IAAI,KAAT,IAAiB,QAAjB,EAA2B;AACvB,gBAAI,OAAO,MAAM,KAAN,CAAX;AACA,gBAAI,IAAJ,EAAU;AACN,qCAAqB,MAArB,EAA6B,KAA7B,EAAmC,KAAK,WAAW,KAAX,CAAL,EAAuB,SAAS,KAAT,CAAvB,EAAuC,IAAvC,CAAnC;AACH,aAFD,MAEO;AACH,qCAAqB,MAArB,EAA6B,KAA7B,EAAmC,WAAW,KAAX,CAAnC;AACH;AACJ;AACJ;;AAED;;;;;;oBAIA,+BAAW;AACP,YAAI,WAAW,KAAK,QAApB;AACA,YAAI,SAAS,KAAK,MAAlB;AACA,aAAK,IAAI,MAAT,IAAiB,QAAjB,EAA2B;AACvB,iCAAqB,MAArB,EAA6B,MAA7B,EAAmC,SAAS,MAAT,CAAnC;AACH;AACJ;;;;;AAGL;;;AACA,SAAS,SAAT,CAAmB,KAAnB,EAA0B,GAA1B,EAA+B,CAA/B,EAAkC;AAC9B,WAAO,QAAQ,CAAC,MAAM,KAAP,IAAgB,CAA/B;AACH;;AAED,IAAM,QAAQ;AACV;AACA,OAAG,SAFO;AAGV,OAAG,SAHO;AAIV;AACA,QAAI,SALM;AAMV,QAAI,SANM;AAOV;AACA,QAAI,SARM;AASV,QAAI,SATM;AAUV;AACA,OAAG,YAXO;AAYV;AACA,OAAG,SAbO;AAcV;AACA;AACA,OAAG,IAhBO;AAiBV;AACA,OAAG,IAlBO,EAkBD;AACT,OAAG,IAnBO,EAmBD;AACT,OAAG,IApBO,EAoBD;AACT,OAAG,IArBO,CAqBF;AArBE,CAAd;;AAwBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,IAAM,KAAK,KAAK,EAAhB;AACA,IAAM,SAAS,KAAK,CAApB;;AAEA;AACA;AACA;AACA,SAAS,YAAT,CAAsB,KAAtB,EAA6B,GAA7B,EAAkC,CAAlC,EAAqC;AACjC,QAAI,aAAa,KAAK,GAAL,CAAS,MAAM,KAAf,CAAjB;AACA,QAAI,aAAa,EAAjB,EAAqB;AACjB;AACA,YAAI,MAAM,KAAV,EAAiB;AACb;AACA,qBAAS,MAAT;AACH,SAHD,MAGO;AACH;AACA,mBAAO,KAAK,MAAZ;AACH;AACJ;;AAED;AACA,QAAI,QAAS,QAAS,CAAC,MAAM,KAAP,IAAgB,CAAtC;;AAEA;AACA;;;;AAIA;AACA,WAAO,KAAP;AACH;;AAED,SAAS,oBAAT,CAA8B,MAA9B,EAAsC,IAAtC,EAA4C,KAA5C,EAAmD;AAC/C,YAAQ,IAAR;AACI,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,CAA0B,CAA1B,GAA8B,KAA9B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,CAA0B,CAA1B,GAA8B,KAA9B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,KAAjB,CAAuB,CAAvB,GAA2B,KAA3B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,KAAjB,CAAuB,CAAvB,GAA2B,KAA3B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,IAAjB,CAAsB,CAAtB,GAA0B,KAA1B;AACA;AACJ,aAAK,IAAL;AACI,mBAAO,SAAP,CAAiB,IAAjB,CAAsB,CAAtB,GAA0B,KAA1B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,SAAP,CAAiB,QAAjB,GAA4B,KAA5B;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,KAAP,GAAe,KAAf;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,CAAP,CAAS,KAAT,EADJ,CACqB;AACjB;AACJ,aAAK,GAAL;AACI,mBAAO,CAAP,CAAS,KAAT,CAAe,MAAf,EAAuB,KAAvB,EADJ,CACmC;AAC/B;AACJ,aAAK,GAAL;AACI,mBAAO,OAAP,GAAiB,KAAjB;AACA;AACJ,aAAK,GAAL;AACI,mBAAO,EAAP,CAAU,KAAV,EADJ,CACsB;AAClB;AApCR;AAsCH;;AAED;kBACe;;;;;;;;ACrRf;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAM,iBAAN;;AAEA;;;QAII;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,UAAA;;;;;;AC7BJ;AACA,IAAM,WAAW,KAAK,OAAL,CAAa,QAA9B;AACA,SAAS,oBAAT,CAA8B,KAA9B,EAAqC,SAAS,SAAT,CAAmB,KAAxD;AACA,SAAS,oBAAT,CAA8B,KAA9B,EAAqC,SAAS,SAAT,CAAmB,KAAxD;AACA,SAAS,oBAAT,CAA8B,KAA9B,EAAqC,SAAS,SAAT,CAAmB,KAAxD;;AAEA;;;;;;;;;;AAUA;;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;AAoBA,IAAM,OAAO,SAAP,IAAO,CAAS,OAAT,EAAkB,MAAlB,EAA0B,QAA1B,EAAoC,QAApC,EAA8C;;AAEvD;AACA,QAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,mBAAW,QAAX;AACA,mBAAW,MAAX;AACA,iBAAS,IAAT;AACH,KAJD,MAIO;AACH,YAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,uBAAW,QAAX;AACA,uBAAW,IAAX;AACH;AACJ;;AAED,QAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AAC/B,kBAAU;AACN,mBAAO,OADD;AAEN,oBAAQ,MAFF;AAGN,sBAAU,YAAY,EAHhB;AAIN,sBAAU;AAJJ,SAAV;AAMH;;AAED,cAAU,OAAO,MAAP,CAAc;AACpB,eAAO,IADa;AAEpB,gBAAQ,IAFY;AAGpB,kBAAU,EAHU;AAIpB,kBAAU;AAJU,KAAd,EAKP,WAAW,EALJ,CAAV;;AAOA,QAAM,SAAS,IAAI,KAAK,OAAL,CAAa,MAAjB,EAAf;;AAEA,aAAS,IAAT,GAAgB;AACZ,YAAI,WAAW,IAAI,QAAQ,KAAZ,EAAf;AACA,YAAI,QAAQ,MAAZ,EAAoB;AAChB,oBAAQ,MAAR,CAAe,QAAf,CAAwB,QAAxB;AACH;AACD,YAAI,QAAQ,QAAZ,EAAsB;AAClB,oBAAQ,QAAR,CAAiB,QAAjB,EAA2B,MAA3B;AACH;AACJ;;AAED;AACA,QAAI,SAAS,QAAQ,KAAR,CAAc,MAAd,IAAwB,EAArC;AACA,QAAI,UAAU,OAAO,IAAP,CAAY,MAAZ,EAAoB,MAAlC,EAA0C;AACtC;AACA,YAAI,YAAW,QAAQ,QAAvB;AACA,YAAI,SAAJ,EAAc;AACV,yBAAY,GAAZ;AACH;AACD,aAAK,IAAI,EAAT,IAAe,MAAf,EAAuB;AACnB,mBAAO,GAAP,CAAW,EAAX,EAAe,YAAW,OAAO,EAAP,CAA1B;AACH;AACD,eAAO,IAAP,CAAY,UAAZ,EAAwB,IAAxB,EAA8B,IAA9B;AACH,KAVD,MAUO;AACH;AACA;AACH;;AAED,WAAO,MAAP;AACH,CA5DD;;kBA8De;;;;;;ACzIf;;;;;;;;;;;;;kBAae,IAAI,KAAK,KAAL,CAAW,YAAf;;;;;;;;;ACbf;AACA,IAAI,WAAW,IAAf;;AAEA;;;;;IAIqB;;;;;AAEjB;;;;;iBAKO,+BAAU,KAAK;AAClB;AACA,cAAM,IAAI,MAAJ,CAAW,CAAX,CAAN;;AAEA;AACA,YAAI,IAAI,MAAJ,KAAe,CAAnB,EAAsB;AAClB,kBAAM,IAAI,OAAJ,CAAY,aAAZ,EAA2B,MAA3B,CAAN;AACH;AACD,eAAO,SAAS,GAAT,EAAc,EAAd,CAAP;AACH;;AAED;;;;;;;;;;iBAQO,iCAAW,UAAU,YAAY,UAAU;AAC9C;AACA,YAAM,YAAY,SAAS,MAA3B;AACA,YAAI,YAAY,aAAa,QAA7B,EAAuC;AACnC,qBAAS,MAAT,GAAkB,aAAa,QAA/B;AACA;AACA,gBAAI,YAAY,UAAhB,EAA4B;AACxB;AACA,oBAAI,SAAS,IAAb,EAAmB;AACf,6BAAS,IAAT,CAAc,KAAd,EAAqB,SAArB,EAAgC,UAAhC;AACH,iBAFD,MAEO;AACH;AACA,yBAAK,IAAI,IAAI,SAAb,EAAwB,IAAI,UAA5B,EAAwC,EAAE,CAA1C,EAA6C;AACzC,iCAAS,CAAT,IAAc,KAAd;AACH;AACJ;AACJ;AACJ;AACD;AACA,YAAI,SAAS,IAAb,EAAmB;AACf,qBAAS,IAAT,CAAc,IAAd,EAAoB,UAApB,EAAgC,aAAa,QAA7C;AACH,SAFD,MAEO;AACH,gBAAM,SAAS,SAAS,MAAxB;AACA;AACA,iBAAK,IAAI,KAAI,UAAb,EAAyB,KAAI,MAA7B,EAAqC,EAAE,EAAvC,EAA0C;AACtC,yBAAS,EAAT,IAAc,IAAd;AACH;AACJ;AACJ;;AAED;;;;;;;;;;iBAQO,qDAAqB,WAAW;AACnC,YAAI,SAAS,EAAb;AACA,YAAI,IAAI,CAAR;AACA,YAAI,UAAU;AACV,eAAG,GADO,EACF;AACR,eAAG,GAFO,EAEF;AACR,eAAG,IAHO,EAGD;AACT,eAAG,IAJO,EAID;AACT,eAAG,IALO,EAKD;AACT,eAAG,IANO,EAMD;AACT,eAAG,GAPO,EAOF;AACR,eAAG,GARO,EAQF;AACR,eAAG,GATO,EASF;AACR,eAAG,GAVO,EAUF;AACR,eAAG,GAXO,CAWH;AAXG,SAAd;AAaA,YAAI,UAAJ;AAAA,YACI,SAAS,EADb;AAAA,YAEI,iBAAiB,KAFrB;AAAA,YAGI,aAHJ;AAAA,YAII,QAAQ,EAJZ;;AAMA,eAAO,KAAK,UAAU,MAAtB,EAA8B;AAC1B,gBAAI,UAAU,CAAV,CAAJ;AACA,gBAAI,QAAQ,CAAR,CAAJ,EAAgB;AACZ,oBAAI,CAAC,cAAL,EAAqB;AACjB,qCAAiB,IAAjB;AACA,2BAAO,MAAP,IAAiB,KAAjB;AACH;AACD,oBAAI,IAAJ,EAAU;AACN,0BAAM,IAAN,IAAc,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAd;AACH;AACD,uBAAO,QAAQ,CAAR,CAAP;AACA,yBAAS,EAAT;AACA;AACH;AACD;AAZA,iBAaK,IAAI,CAAC,CAAD,IAAM,MAAM,GAAhB,EAAqB;AACtB;AACA,0BAAM,IAAN,IAAc,KAAK,UAAL,CAAgB,IAAhB,EAAsB,MAAtB,CAAd;AACA,6BAAS,EAAT;AACA,2BAAO,IAAP;AACA,4BAAQ,EAAR;AACA,qCAAiB,KAAjB;AACH,iBAPI,MAOE;AACH,8BAAU,CAAV;AACA;AACH;AACJ;AACD,eAAO,MAAP;AACH;;AAED;;;;;;;;;iBAOO,+CAAkB,KAAK;AAC1B,YAAM,SAAS,EAAf;AACA;AACA,YAAI,SAAS,IAAI,KAAJ,CAAU,IAAV,CAAb;AACA,YAAI,YAAY,cAAhB;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACpC,gBAAI,QAAQ,OAAO,CAAP,EAAU,KAAV,CAAgB,GAAhB,CAAZ,CADoC,CACF;AAClC,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACnC;AACA,oBAAI,MAAM,MAAM,CAAN,CAAV;AACA,oBAAI,IAAI,CAAJ,MAAW,GAAX,IAAkB,CAAC,UAAU,IAAV,CAAe,GAAf,CAAvB,EAA4C;AACxC,0BAAM,CAAN,IAAW,WAAW,GAAX,CAAX;AACH;AACJ;AACD,mBAAO,IAAP,CAAY,KAAZ;AACH;AACD,eAAO,MAAP;AACH;;AAED;;;;;;;;;;;iBASO,iCAAW,MAAM,QAAQ;AAC5B,gBAAQ,IAAR;AACI;AACA,iBAAK,GAAL;AACI;AACI,6BAAS,OAAO,KAAP,CAAa,GAAb,CAAT;AACA,2BAAO,OAAP,CAAe,UAAS,GAAT,EAAc,CAAd,EAAiB,MAAjB,EAAyB;AACpC,+BAAO,CAAP,IAAY,WAAW,GAAX,CAAZ;AACH,qBAFD;AAGA,2BAAO,MAAP;AACH;AACD;AACA;AACJ,iBAAK,GAAL;AACI;AACI,2BAAO,MAAP;AACH;AACD;AACJ,iBAAK,GAAL;AACI;AACI,2BAAO,CAAC,CAAC,SAAS,MAAT,CAAT;AACH;AACD;AACJ;AACI;AACI,2BAAO,WAAW,MAAX,CAAP;AACH;AAzBT;AA2BH;;AAED;;;;;;;;;;iBAQO,yBAAO,UAAU,eAAe,MAAM;AACzC,YAAI,CAAC,QAAL,EAAe;AACX,uBAAW,SAAS,OAAT,CAAiB,OAA5B;AACA,qBAAS,QAAT,CAAkB,KAAK,aAAvB;AACH;AACD,iBAAS,MAAT,CAAgB,aAAhB,EAA+B,IAA/B;AACH;;AAED;;;;;;;;;iBAOO,uCAAc,MAAM;AACvB,YAAI,gBAAgB,KAAK,OAAL,CAAa,SAAjC,EAA4C;AACxC,iBAAK,oBAAL,CAA0B,OAA1B,CAAkC,UAAC,QAAD,EAAc;AAC5C,oBAAM,QAAQ,KAAK,QAAL,CAAc,OAAd,CAAsB,SAAS,MAA/B,CAAd;AACA,oBAAI,UAAU,CAAC,CAAf,EAAkB;AACd,6BAAS,GAAT,CAAa,SAAS,MAAtB;AACH;AACJ,aALD;AAMA,mBAAO,IAAP;AACH;AACD,eAAO,KAAP;AACH;;;;;kBAvNgB;;;;;ACPrB;;;;;AAKA,IAAM,IAAI,KAAK,SAAL,CAAe,SAAzB;;AAEA;;;;;;AAMA,EAAE,EAAF,GAAO,EAAE,QAAT;;AAEA;;;;;;;AAOA;;;;;;;AAOA,KAAK,SAAL,CAAe,MAAf,GAAwB,KAAK,SAAL,CAAe,CAAf,GAAmB,UAAS,KAAT,EAAgB;AACvD,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;AC7BA;;;;;;AAEA;;;;;AAKA,IAAM,IAAI,KAAK,aAAL,CAAmB,SAA7B;;AAEA;AACA,IAAI,0BAAJ;AACA,IAAI,KAAK,OAAT,EAAkB;AACd,sBAAoB,KAAK,OAAL,CAAa,iBAAjC;AACH;;AAED;;;;;;AAMA;;;;;;AAMA,EAAE,aAAF,GAAkB,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AAC1C,OAAK,UAAL,GAAkB,CAAC,CAAC,UAApB;AACA,SAAO,IAAP;AACH,CAHD;;AAKA;;;;;;;;;;;;;AAaA,EAAE,CAAF,GAAM,EAAE,YAAR;;AAEA;;;;;;AAMA;;;;;;AAMA,EAAE,OAAF,GAAY,EAAE,EAAF,GAAO,UAAS,IAAT,EAAe;AAC9B;AACA;AACA;AACA,MAAI,IAAJ,EAAU;AACN,QAAI,EAAE,gBAAgB,KAAK,QAAvB,KAAoC,EAAE,gBAAgB,KAAK,MAAvB,CAAxC,EAAwE;AACpE,UAAI,OAAO,OAAP,KAAmB,WAAnB,IAAkC,QAAQ,IAA9C,EAAoD;AAChD,gBAAQ,IAAR,CAAa,kEAAb;AACH;AACD,aAAO,IAAP;AACH;AACJ;AACD,OAAK,IAAL,GAAY,IAAZ;AACA,SAAO,IAAP;AACH,CAdD;;AAgBA;;;;;;AAMA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,CAAF,GAAM,UAAS,KAAT,EAAgB;AAC/B,OAAK,KAAL,GAAa,KAAb;AACA,SAAO,IAAP;AACH,CAHD;;AAKA;;;;;;AAMA;;;;;;AAMA,EAAE,OAAF,GAAY,EAAE,CAAF,GAAM,UAAS,IAAT,EAAe;AAC7B,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,WAAO,gBAAM,SAAN,CAAgB,IAAhB,CAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAI,IAAI,QAAQ,EAAR,GAAa,IAArB;AACA,MAAI,IAAI,QAAQ,CAAR,GAAY,IAApB;AACA,MAAI,IAAI,OAAO,IAAf;AACA,SAAO,KAAK,CAAL,CAAO,IAAI,GAAX,EAAgB,CAAhB,EAAmB,IAAI,GAAvB,EAA4B,CAA5B,EAA+B,IAAI,GAAnC,EAAwC,CAAxC,CAAP;AACH,CAdD;;AAgBA;;;;;;;;;;;AAWA;;;;;;;;;;;AAWA,EAAE,iBAAF,GAAsB,EAAE,CAAF,GAAM,UAAS,CAAT,EAAY,EAAZ,EAAgB,CAAhB,EAAmB,EAAnB,EAAuB,CAAvB,EAA0B,EAA1B,EAA8B;AACtD,MAAI,SAAS,KAAK,oBAAlB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,CAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,EAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,CAAnB;AACA,SAAO,MAAP,CAAc,CAAd,IAAmB,EAAnB;AACA,SAAO,MAAP,CAAc,EAAd,IAAoB,CAApB;AACA,SAAO,MAAP,CAAc,EAAd,IAAoB,EAApB;AACA,OAAK,OAAL,GAAe,CAAC,MAAD,CAAf;AACA,SAAO,IAAP;AACH,CAVD;;AAYA;;;;AAIA,IAAI,CAAC,EAAE,cAAF,CAAiB,sBAAjB,CAAL,EAA+C;AAC3C,SAAO,cAAP,CAAsB,CAAtB,EAAyB,sBAAzB,EAAiD;AAC7C,SAAK,aAAS,MAAT,EAAiB;AAClB,WAAK,qBAAL,GAA6B,MAA7B;AACH,KAH4C;AAI7C,SAAK,eAAW;AACZ,aAAO,KAAK,qBAAL,IAA8B,IAAI,iBAAJ,EAArC;AACH;AAN4C,GAAjD;AAQH;;AAED;;;;;;;AAOA;;;;;;;AAOA,KAAK,aAAL,CAAmB,MAAnB,GAA4B,KAAK,aAAL,CAAmB,CAAnB,GAAuB,UAAS,KAAT,EAAgB;AAC/D,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;ACvLA;;;;;AAKA,IAAM,IAAI,KAAK,QAAL,CAAc,SAAxB;;AAEA;;;;;;AAMA;;;;;;;AAOA,EAAE,YAAF,GAAiB,EAAE,CAAF,GAAM,UAAS,QAAT,EAAmB;AACtC,MAAI,cAAJ;AAAA,MAAoB,SAAS,EAA7B;AAAA,MACI,IAAI,CADR;;AAGA,SAAO,KAAK,SAAS,MAArB,EAA6B;AACzB,QAAI,OAAO,SAAS,GAAT,CAAX;AACA,QAAI,SAAS,SAAT,IAAsB,KAAK,IAAL,CAA1B,EAAsC;AAClC,UAAI,cAAJ,EAAoB;AAChB,aAAK,cAAL,EAAqB,KAArB,CAA2B,IAA3B,EAAiC,MAAjC;AACA,eAAO,MAAP,GAAgB,CAAhB;AACH;AACD,uBAAiB,IAAjB;AACH,KAND,MAMO;AACH,aAAO,IAAP,CAAY,IAAZ;AACH;AACJ;AACD,SAAO,IAAP;AACH,CAjBD;;AAmBA;;;;;;AAMA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;AAKA,EAAE,CAAF,GAAM,EAAE,OAAR;;AAEA;;;;;;;AAOA,EAAE,CAAF,GAAM,EAAE,MAAR;;AAEA;;;;;;;AAOA,EAAE,CAAF,GAAM,EAAE,MAAR;;AAEA;;;;;;;;;;;AAWA,EAAE,CAAF,GAAM,EAAE,gBAAR;;AAEA;;;;;;;;;;;AAWA,EAAE,CAAF,GAAM,EAAE,aAAR;;AAEA;;;;;;;;AAQA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;;;;;AASA,EAAE,CAAF,GAAM,EAAE,SAAR;;AAEA;;;;;;;;;AASA;;;;;;;;;AASA,EAAE,EAAF,GAAO,EAAE,QAAT;;AAEA;;;;;;;;;;AAUA,EAAE,EAAF,GAAO,EAAE,eAAT;;AAEA;;;;;;;;;;;;;AAaA,EAAE,EAAF,GAAO,EAAE,eAAT;;AAEA;;;;;;;;AAQA,EAAE,EAAF,GAAO,EAAE,UAAT;;AAEA;;;;;;;;;;;AAWA,EAAE,EAAF,GAAO,EAAE,GAAT;;AAEA;;;;;;;;;;AAUA,EAAE,EAAF,GAAO,EAAE,KAAT;;AAEA;;;;;;;;AAQA,EAAE,EAAF,GAAO,EAAE,WAAT;;AAEA;;;;;;;AAOA,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AACxB;AACA,UAAQ,IAAR,CAAa,yCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,WAAW,CAAX,CAAP,CAAP;AACH,CALD;;AAOA;;;;;;;AAOA,EAAE,EAAF,GAAO,UAAS,UAAT,EAAqB;AACxB;AACA,UAAQ,IAAR,CAAa,yCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,WAAW,CAAX,CAAP,CAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,gCAAb;AACA;AACA,SAAO,KAAK,CAAL,CAAO,GAAP,CAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,kCAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,kCAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,2CAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;AAOA;;;;;AAKA,EAAE,EAAF,GAAO,YAAW;AACd;AACA,UAAQ,IAAR,CAAa,2CAAb;AACA;AACA,SAAO,IAAP;AACH,CALD;;;;;ACpSA;;;;;AAKA,IAAM,IAAI,KAAK,MAAL,CAAY,SAAtB;;AAEA;;;;;;;AAOA;;;;;;;AAOA,KAAK,MAAL,CAAY,MAAZ,GAAqB,KAAK,MAAL,CAAY,CAAZ,GAAgB,UAAS,KAAT,EAAgB;AACjD,QAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,CAAd,CAAlB;AACA,QAAM,SAAN,CAAgB,QAAhB,GAA2B,CAA3B;AACA,QAAM,SAAN,CAAgB,WAAhB,GAA8B,KAA9B;AACA,SAAO,KAAP;AACH,CALD;;;;;ACrBA;;;;;AAKA,IAAM,IAAI,KAAK,IAAL,CAAU,SAApB;;AAEA;AACA,IAAM,eAAe,CAAC,QAAD,EAAW,OAAX,CAArB;;AAEA;;;;;;;AAOA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,CAAF,GAAM,UAAS,KAAT,EAAgB;AAC/B,QAAI,OAAO,KAAP,IAAgB,QAApB,EAA8B;AAC1B,gBAAQ,aAAa,OAAb,CAAqB,KAArB,CAAR;AACH;AACD,SAAK,KAAL,CAAW,KAAX,GAAmB,aAAa,KAAb,KAAuB,MAA1C;AACA,SAAK,MAAL,CAAY,CAAZ,GAAgB,CAAC,QAAQ,CAAT,IAAc,CAA9B;AACA,WAAO,IAAP;AACH,CAPD;;AASA;AACA,IAAI,cAAc;AACd,OAAG,MADW,EACH;AACX,OAAG,UAFW;AAGd,OAAG,YAHW;AAId,OAAG,WAJW;AAKd,OAAG,YALW;AAMd,OAAG,MANW;AAOd,OAAG,OAPW;AAQd,OAAG,QARW;AASd,OAAG,iBATW;AAUd,OAAG,UAVW;AAWd,OAAG,eAXW;AAYd,OAAG,YAZW;AAad,OAAG,YAbW;AAcd,OAAG,iBAdW;AAed,OAAG,iBAfW;AAgBd,OAAG,gBAhBW;AAiBd,OAAG,SAjBW;AAkBd,OAAG,cAlBW;AAmBd,OAAG,UAnBW;AAoBd,OAAG,YApBW;AAqBd,OAAG;AArBW,CAAlB;;AAwBA;;;;;;AAMA;;;;;;AAMA,EAAE,QAAF,GAAa,EAAE,EAAF,GAAO,UAAS,KAAT,EAAgB;AAChC;AACA,SAAK,IAAI,CAAT,IAAc,WAAd,EAA2B;AACvB,YAAI,MAAM,CAAN,MAAa,SAAjB,EAA4B;AACxB,kBAAM,YAAY,CAAZ,CAAN,IAAwB,MAAM,CAAN,CAAxB;AACA,mBAAO,MAAM,CAAN,CAAP;AACH;AACJ;AACD,SAAK,KAAL,GAAa,KAAb;AACA,WAAO,IAAP;AACH,CAVD;;AAYA;;;;;;;;AAQA;;;;;;;;AAQA,EAAE,SAAF,GAAc,EAAE,EAAF,GAAO,UAAS,KAAT,EAAgB,KAAhB,EAAuB,QAAvB,EAAiC;AAClD,QAAI,QAAQ,KAAK,KAAjB;AACA,UAAM,UAAN,GAAmB,IAAnB;;AAEA;AACA,QAAI,UAAU,SAAd,EAAyB;AACrB,gBAAQ,MAAM,MAAM,QAAN,CAAe,EAAf,CAAd;AACH;AACD,UAAM,eAAN,GAAwB,cAAc,KAAd,EAAqB,MAAM,eAA3B,CAAxB;AACA,UAAM,eAAN,GAAwB,cAAc,KAAd,EAAqB,MAAM,eAA3B,CAAxB;AACA,UAAM,kBAAN,GAA2B,cAAc,QAAd,EAAwB,MAAM,kBAA9B,CAA3B;AACA,WAAO,IAAP;AACH,CAZD;;AAcA;;;;;;;;AAQA,IAAI,gBAAgB,SAAhB,aAAgB,CAAS,KAAT,EAAgB,YAAhB,EAA8B;AAC9C,WAAO,UAAU,SAAV,GAAsB,YAAtB,GAAqC,KAA5C;AACH,CAFD;;;;;;;ACvHA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA;;;kBAGe;AACX,kCADW;AAEX,0CAFW;AAGX,4BAHW;AAIX,gCAJW;AAKX;AALW;;;;;ACTf;AACA,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;AAC7B,UAAM,eAAN;AACH;;AAED,IAAI,CAAC,KAAK,OAAV,EAAmB;AACf;AACA,YAAQ,UAAR;;AAEA;AACA,WAAO,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACnC,oBAAY,IADuB;AAEnC,WAFmC,iBAE7B;AAAE,mBAAO,QAAQ,WAAR,CAAP;AAA8B;AAFH,KAAvC;AAIH;;AAED;AACA,IAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,OAAO,OAA5C,EAAqD;AACjD,WAAO,OAAP,GAAiB,KAAK,OAAtB;AACH","file":"pixi-animate.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","import AnimatorTimeline from './AnimatorTimeline';\n\n// Static collection of timelines\nconst timelines = [];\n\n/**\n * Play animation via start/stop frame labels\n * @class Animator\n * @memberof PIXI.animate\n */\nclass Animator {\n\n    /**\n     * The collection of timelines\n     * @name {Array<PIXI.animate.AnimatorTimeline>} PIXI.animate.Animator#_timelines\n     * @private\n     * @static\n     */\n    static get _timelines() {\n        return timelines;\n    }\n\n    /**\n     * Suffix added to label for a stop.\n     * @name {String} PIXI.animate.Animator.STOP_LABEL\n     * @static\n     * @default \"_stop\"\n     */\n    static get STOP_LABEL() {\n        return \"_stop\";\n    }\n\n    /**\n     * Suffix added to label for a loop.\n     * @name {String} PIXI.animate.Animator.LOOP_LABEL\n     * @static\n     * @default \"_loop\"\n     */\n    static get LOOP_LABEL() {\n        return \"_loop\";\n    }\n\n    /**\n     * Play an animation by frame labels. For instance, play animation sequence from\n     * \"idle\" to \"idle_stop\" or \"idle_loop\". If no event label is provided, will\n     * play the entire duration of the MovieClip.\n     * @method PIXI.animate.Animator#play\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Function} [label] The frame label event to call, if no event is provided\n     *        will use the entire length of the MovieClip. Can also be the callback.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static play(instance, label, callback) {\n        let loop = false;\n        let start, end;\n        const labelIsFunction = typeof label === \"function\";\n        if (label === undefined || labelIsFunction) {\n            start = 0;\n            end = instance.totalFrames - 1;\n            if (labelIsFunction) {\n                callback = label;\n            }\n        } else {\n            start = instance.labelsMap[label];\n            end = instance.labelsMap[label + this.STOP_LABEL];\n            if (end === undefined) {\n                end = instance.labelsMap[label + this.LOOP_LABEL];\n                loop = true;\n            }\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + label + \"'\");\n            } else if (end === undefined) {\n                throw new Error(\"No end label matching '\" + label + \"'\");\n            }\n        }\n        return this.fromTo(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n    }\n\n    /**\n     * Play an animation from the current frame to an end frame or label.\n     * @method PIXI.animate.Animator#to\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {String|Number} end The end frame or label.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static to(instance, end, callback) {\n        return this.fromTo(\n            instance,\n            instance.currentFrame,\n            end,\n            false,\n            callback\n        );\n    }\n\n    /**\n     * Play a MovieClip from a start to end frame.\n     * @method PIXI.animate.Animator#fromTo\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     * @param {Number|String} start The starting frame index or label.\n     * @param {Number|String} end The ending frame index or label.\n     * @param {Boolean} [loop=false] If the animation should loop.\n     * @param {Function} [callback] Optional callback when complete\n     * @return {PIXI.animate.AnimatorTimeline} Timeline object for stopping or getting progress.\n     */\n    static fromTo(instance, start, end, loop, callback) {\n\n        if (typeof start === \"string\") {\n            const startLabel = start;\n            start = instance.labelsMap[startLabel];\n            if (start === undefined) {\n                throw new Error(\"No start label matching '\" + startLabel + \"'\");\n            }\n        }\n        if (typeof end === \"string\") {\n            const endLabel = end;\n            end = instance.labelsMap[endLabel];\n            if (end === undefined) {\n                throw new Error(\"No end label matching '\" + endLabel + \"'\");\n            }\n        }\n        if (start < 0) {\n            throw new Error('Start frame is out of bounds');\n        }\n        if (end >= instance.totalFrames) {\n            throw new Error('End frame is out of bounds');\n        }\n        if (start >= end) {\n            throw new Error('End frame is before start frame');\n        }\n\n        // Stop any animation that's playing\n        this.stop(instance);\n\n        loop = !!loop;\n\n        // Add a new timeline\n        const timeline = AnimatorTimeline.create(\n            instance,\n            start,\n            end,\n            loop,\n            callback\n        );\n        this._timelines.push(timeline);\n\n        // Set the current frame\n        if (instance.currentFrame !== start) {\n            instance.gotoAndPlay(start);\n        } else {\n            instance.play();\n        }\n        return timeline;\n    }\n\n    /**\n     * Stop the animation by instance.\n     * @method PIXI.animate.Animator#stop\n     * @static\n     * @param {PIXI.animate.MovieClip} instance Movie clip to play.\n     */\n    static stop(instance) {\n        for (let i = 0, len = this._timelines.length; i < len; i++) {\n            const timeline = this._timelines[i];\n            if (timeline.instance === instance) {\n                this._internalStop(timeline);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Stop all the currently playing animations.\n     * @method PIXI.animate.Animator#stopAll\n     * @static\n     */\n    static stopAll() {\n        for (let i = this._timelines.length - 1; i >= 0; i--) {\n            this._internalStop(this._timelines[i]);\n        }\n    }\n\n    /**\n     * Stop the animation\n     * @method PIXI.animate.Animator#_internalStop\n     * @private\n     * @static\n     * @param {PIXI.animate.AnimatorTimeline} timeline Timeline to stop.\n     */\n    static _internalStop(timeline) {\n        this._timelines.splice(this._timelines.indexOf(timeline), 1);\n        timeline.instance.stop();\n        timeline.destroy();\n    }\n}\n\nmodule.exports = Animator;","const pool = [];\n\n/**\n * Represents a single animation play.\n * @class AnimatorTimeline\n * @memberof PIXI.animate\n */\nclass AnimatorTimeline {\n    constructor() {\n        this._update = this.update.bind(this);\n        this.init(null, 0, 0, false, null);\n    }\n\n    /**\n     * The pool of timelines to use\n     * @method PIXI.animate.AnimatorTimeline#init\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @private\n     */\n    init(instance, start, end, loop, callback) {\n\n        /**\n         * Instance of clip to play.\n         * @name PIXI.animate.AnimatorTimeline#instance\n         * @type {PIXI.animate.MovieClip}\n         * @readOnly\n         */\n        this.instance = instance;\n\n        /**\n         * `true` if the timeline is suppose to loop.\n         * @name PIXI.animate.AnimatorTimeline#loop\n         * @type {Boolean}\n         * @readOnly\n         */\n        this.loop = loop;\n\n        /**\n         * Frame number of the starting farme.\n         * @name PIXI.animate.AnimatorTimeline#start\n         * @type {int}\n         * @readOnly\n         */\n        this.start = start;\n\n        /**\n         * Frame number of the ending frame.\n         * @name PIXI.animate.AnimatorTimeline#end\n         * @type {int}\n         * @readOnly\n         */\n        this.end = end;\n\n        /**\n         * Callback called when completed (non-looping animation).\n         * @name PIXI.animate.AnimatorTimeline#callback\n         * @type {Function}\n         * @readOnly\n         */\n        this.callback = callback;\n\n        if (instance) {\n            instance.gotoAndStop(start);\n            instance._beforeUpdate = this._update;\n        }\n    }\n\n    /**\n     * Don't use after this\n     * @method PIXI.animate.AnimatorTimeline#destroy\n     * @private\n     */\n    destroy() {\n        this.instance._beforeUpdate = null;\n        this.init(null, 0, 0, false, null);\n        AnimatorTimeline._pool.push(this);\n    }\n\n    /**\n     * Is the animation complete\n     * @method PIXI.animate.AnimatorTimeline#update\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {Function} Callback to do after updateTimeline\n     * @private\n     */\n    update(instance) {\n        let completed;\n        if (instance.currentFrame >= this.end) {\n\n            // In case we over-shoot the current frame becuase of low FPS\n            instance.currentFrame = this.end;\n\n            if (this.loop) {\n                // Update timeline so we get actions at the end frame\n                instance._updateTimeline();\n                instance.gotoAndPlay(this.start);\n            } else {\n                instance.stop();\n                if (this.callback) {\n                    completed = this.callback;\n                }\n                this.stop(); // cleanup timeline\n            }\n        }\n        return completed;\n    }\n\n    /**\n     * Stop the animation, cannot be reused.\n     * @method PIXI.animate.AnimatorTimeline#stop\n     */\n    stop() {\n        PIXI.animate.Animator._internalStop(this);\n    }\n\n    /**\n     * The progress from 0 to 1 of the playback.\n     * @name PIXI.animate.AnimatorTimeline#progress\n     * @type {Number}\n     * @readOnly\n     */\n    get progress() {\n        const progress = (this.instance.currentFrame - this.start) / (this.end - this.start);\n        return Math.max(0, Math.min(1, progress)); // clamp\n    }\n\n    /**\n     * The pool of timelines to use\n     * @name PIXI.animate.AnimatorTimeline._pool\n     * @type {Array<PIXI.animate.AnimatorTimeline>}\n     * @static\n     * @private\n     */\n    static get _pool() {\n        return pool;\n    }\n\n    /**\n     * Create a new timeline\n     * @method PIXI.animate.AnimatorTimeline.create\n     * @static\n     * @param {PIXI.animate.MovieClip} instance\n     * @param {Number} start\n     * @param {Number} end\n     * @param {Boolean} loop\n     * @param {Function} callback\n     * @return {PIXI.animate.AnimatorTimeline}\n     */\n    static create(instance, start, end, loop, callback) {\n        var timeline;\n        if (this._pool.length) {\n            timeline = this._pool.pop();\n        } else {\n            timeline = new AnimatorTimeline();\n        }\n        timeline.init(instance, start, end, loop, callback);\n        return timeline;\n    }\n}\n\nmodule.exports = AnimatorTimeline;","import Timeline from './Timeline';\nimport utils from './utils';\n\nconst Container = PIXI.Container;\nconst SharedTicker = PIXI.ticker.shared;\n\n/**\n * Provide timeline playback of movieclip\n * @memberof PIXI.animate\n * @class MovieClip\n * @extends PIXI.Container\n * @constructor\n * @param {Object|int} [options] The options object or the mode to play\n * @param {int} [options.mode=0] The playback mode default is independent (0),\n * @param {int} [options.startPosition=0] The starting frame\n * @param {Boolean} [options.loop=true] If playback is looped\n * @param {Object} [options.labels] The frame labels map of label to frames\n * @param {int} [options.duration] The duration, if no duration is provided, auto determines length\n * @param {int} [options.framerate=24] The framerate to use for independent mode\n */\nclass MovieClip extends Container {\n    constructor(options, duration, loop, framerate, labels) {\n        super();\n\n        // Default options\n        options = options === undefined ? {} : options;\n\n        // Options can also be the mode\n        if (typeof options === 'number') {\n            options = {\n                mode: options || MovieClip.INDEPENDENT,\n                duration: duration || 0,\n                loop: loop === undefined ? true : loop,\n                labels: labels || {},\n                framerate: framerate || 0,\n                startPosition: 0\n            };\n        } else {\n            // Apply defaults to options\n            options = Object.assign({\n                mode: MovieClip.INDEPENDENT,\n                startPosition: 0,\n                loop: true,\n                labels: {},\n                duration: 0,\n                framerate: 0\n            }, options);\n        }\n\n        /**\n         * Controls how this MovieClip advances its time. Must be one of 0 (INDEPENDENT), 1 (SINGLE_FRAME), or 2 (SYNCHED).\n         * See each constant for a description of the behaviour.\n         * @name PIXI.animate.MovieClip#mode\n         * @type int\n         * @default null\n         */\n        this.mode = options.mode;\n\n        /**\n         * Specifies what the first frame to play in this movieclip, or the only frame to display if mode is SINGLE_FRAME.\n         * @name PIXI.animate.MovieClip#startPosition\n         * @type Number\n         * @default 0\n         */\n        this.startPosition = options.startPosition;\n\n        /**\n         * Indicates whether this MovieClip should loop when it reaches the end of its timeline.\n         * @name PIXI.animate.MovieClip#loop\n         * @type Boolean\n         * @default true\n         */\n        this.loop = !!options.loop;\n\n        /**\n         * The current frame of the movieclip.\n         * @name PIXI.animate.MovieClip#currentFrame\n         * @type Number\n         * @default 0\n         * @readOnly\n         */\n        this.currentFrame = 0;\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labels\n         * @type Array\n         * @private\n         */\n        this._labels = [];\n\n        /**\n         * The collection of private labels\n         * @name PIXI.animate.MovieClip#_labelDict\n         * @type Object\n         * @private\n         */\n        this._labelDict = options.labels;\n        if (options.labels) {\n            for (let name in options.labels) {\n                let label = {\n                    label: name,\n                    position: options.labels[name]\n                };\n                this._labels.push(label);\n            }\n            this._labels.sort(function(a, b) {\n                return a.position - b.position;\n            });\n        }\n\n        /**\n         * If true, this movieclip will animate automatically whenever it is on the stage.\n         * @name PIXI.animate.MovieClip#selfAdvance\n         * @type Boolean\n         * @default true\n         */\n        this.selfAdvance = true;\n\n        /**\n         * If true, the MovieClip's position will not advance when ticked.\n         * @name PIXI.animate.MovieClip#paused\n         * @type Boolean\n         * @default false\n         */\n        this.paused = false;\n\n        /**\n         * If true, actions in this MovieClip's tweens will be run when the playhead advances.\n         * @name PIXI.animate.MovieClip#actionsEnabled\n         * @type Boolean\n         * @default true\n         */\n        this.actionsEnabled = true;\n\n        /**\n         * If true, the MovieClip will automatically be reset to its first frame whenever the timeline adds\n         * it back onto the display list. This only applies to MovieClip instances with mode=INDEPENDENT.\n         * <br><br>\n         * For example, if you had a character animation with a 'body' child MovieClip instance\n         * with different costumes on each frame, you could set body.autoReset = false, so that\n         * you can manually change the frame it is on, without worrying that it will be reset\n         * automatically.\n         * @name PIXI.animate.MovieClip#autoReset\n         * @type Boolean\n         * @default true\n         */\n        this.autoReset = true;\n\n        /**\n         * @name PIXI.animate.MovieClip#_synchOffset\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._synchOffset = 0;\n\n        /**\n         * @name PIXI.animate.MovieClip#_prevPos\n         * @type Number\n         * @default -1\n         * @private\n         */\n        this._prevPos = -1; // TODO: evaluate using a ._reset Boolean prop instead of -1.\n\n        /**\n         * Note - changed from default: When the MovieClip is framerate independent, this is the time\n         * elapsed from frame 0 in seconds.\n         * @name PIXI.animate.MovieClip#_t\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._t = 0;\n\n        /**\n         * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n         * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n         * framerate.\n         *\n         * @name PIXI.animate.MovieClip#_framerate\n         * @type {Number}\n         * @default 0\n         * @protected\n         */\n        this._framerate = options.framerate;\n\n        /**\n         * The total time in seconds for the animation. This is changed when setting the framerate.\n         * @name PIXI.animate.MovieClip#_duration\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._duration = 0;\n\n        /**\n         * The total duration in frames for the animation.\n         * @name PIXI.animate.MovieClip#_totalFrames\n         * @type Number\n         * @default 0\n         * @private\n         */\n        this._totalFrames = options.duration;\n\n        /**\n         * Standard tween timelines for all objects. Each element in the _timelines array\n         * is a Timeline object - an array of tweens for one target, in order of occurrence.\n         * @name PIXI.animate.MovieClip#_timelines\n         * @type Array\n         * @protected\n         */\n        this._timelines = [];\n\n        /**\n         * Array of child timelines denoting if a child is actively a child of this movieclip\n         * on any given frame. Each element in the _timedChildTimelines is an array with a 'target'\n         * property, and is an array of boolean values indexed by frame.\n         * @name PIXI.animate.MovieClip#_timedChildTimelines\n         * @type {Array}\n         * @protected\n         */\n        this._timedChildTimelines = [];\n\n        /**\n         * Array to depth sort timed children\n         * @name PIXI.animate.MovieClip#_depthSorted\n         * @type {Array}\n         * @private\n         */\n        this._depthSorted = [];\n\n        /**\n         * Array of frame scripts, indexed by frame.\n         * @name PIXI.animate.MovieClip#_actions\n         * @type {Array}\n         * @protected\n         */\n        this._actions = [];\n\n        /**\n         * Optional callback fired before timeline is updated.\n         * Can be used to clamp or update the currentFrame.\n         * @name PIXI.animate.MovieClip#_beforeUpdate\n         * @type {Function}\n         * @private\n         */\n        this._beforeUpdate = null;\n\n        if (this.mode === MovieClip.INDEPENDENT) {\n            this._tickListener = this._tickListener.bind(this);\n            this._onAdded = this._onAdded.bind(this);\n            this._onRemoved = this._onRemoved.bind(this);\n            this.on('added', this._onAdded);\n            this.on('removed', this._onRemoved);\n        }\n\n        if (options.framerate) {\n            this.framerate = options.framerate;\n        }\n\n        //save often used methods on the instance so that they can be fetched slightly faster\n        //than if they had to be fetched from the prototype\n        this.advance = this.advance;\n        this._updateTimeline = this._updateTimeline;\n        this._setTimelinePosition = this._setTimelinePosition;\n        this._goto = this._goto;\n    }\n\n    _onAdded() {\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n        SharedTicker.add(this._tickListener);\n    }\n\n    _tickListener(tickerDeltaTime) {\n        if (this.paused || !this.selfAdvance) {\n            //see if the movieclip needs to be updated even though it isn't animating\n            if (this._prevPos < 0) {\n                this._goto(this.currentFrame);\n            }\n            return;\n        }\n        let seconds = tickerDeltaTime / SharedTicker.speed / PIXI.settings.TARGET_FPMS / 1000;\n        this.advance(seconds);\n    }\n\n    _onRemoved() {\n        SharedTicker.remove(this._tickListener);\n    }\n\n    /**\n     * Returns an array of objects with label and position (aka frame) properties, sorted by position.\n     * @name PIXI.animate.MovieClip#labels\n     * @type {Array}\n     * @readonly\n     */\n    get labels() {\n        return this._labels;\n    }\n\n    /**\n     * Returns a dictionary of labels where key is the label and value is the frame.\n     * @name PIXI.animate.MovieClip#labelsMap\n     * @type {Object}\n     * @readonly\n     */\n    get labelsMap() {\n        return this._labelDict;\n    }\n\n    /**\n     * Returns the name of the label on or immediately before the current frame.\n     * @name PIXI.animate.MovieClip#currentLabel\n     * @type {String}\n     * @readonly\n     */\n    get currentLabel() {\n        let labels = this._labels;\n        let current = null;\n        for (let i = 0, len = labels.length; i < len; ++i) {\n            if (labels[i].position <= this.currentFrame) {\n                current = labels[i].label;\n            } else {\n                break;\n            }\n        }\n        return current;\n    }\n\n    /**\n     * When the MovieClip is framerate independent, this is the time elapsed from frame 0 in seconds.\n     * @name PIXI.animate.MovieClip#elapsedTime\n     * @type Number\n     * @default 0\n     * @public\n     */\n    get elapsedTime() {\n        return this._t;\n    }\n\n    set elapsedTime(value) {\n        this._t = value;\n    }\n\n    /**\n     * By default MovieClip instances advance one frame per tick. Specifying a framerate for the MovieClip\n     * will cause it to advance based on elapsed time between ticks as appropriate to maintain the target\n     * framerate.\n     *\n     * For example, if a MovieClip with a framerate of 10 is placed on a Stage being updated at 40fps, then the MovieClip will\n     * advance roughly one frame every 4 ticks. This will not be exact, because the time between each tick will\n     * vary slightly between frames.\n     *\n     * This feature is dependent on the tick event object (or an object with an appropriate 'delta' property) being\n     * passed into {{#crossLink 'Stage/update'}}{{/crossLink}}.\n     * @name PIXI.animate.MovieClip#framerate\n     * @type {Number}\n     * @default 0\n     */\n    get framerate() {\n        return this._framerate;\n    }\n    set framerate(value) {\n        if (value > 0) {\n            this._framerate = value;\n            this._duration = value ? this._totalFrames / value : 0;\n            this._t = this.currentFrame / value;\n        } else {\n            this._t = this._framerate = this._duration = 0;\n        }\n    }\n\n    /**\n     * Get the total number of frames (duration) of this MovieClip\n     * @name PIXI.animate.MovieClip#totalFrames\n     * @type {Number}\n     * @default 0\n     * @readOnly\n     */\n    get totalFrames() {\n        return this._totalFrames;\n    }\n\n    /**\n     * Extend the timeline to the last frame.\n     * @method PIXI.animate.MovieClip#_autoExtend\n     * @private\n     * @param {int} endFrame\n     */\n    _autoExtend(endFrame) {\n        if (this._totalFrames < endFrame) {\n            this._totalFrames = endFrame;\n        }\n    }\n\n    /**\n     * Convert values of properties\n     * @method PIXI.animate.MovieClip#_parseProperties\n     * @private\n     * @param {Object} properties\n     */\n    _parseProperties(properties) {\n        // Convert any string colors to uints\n        if (typeof properties.t === 'string') {\n            properties.t = utils.hexToUint(properties.t);\n        } else if (typeof properties.v === 'number') {\n            properties.v = !!properties.v;\n        }\n    }\n\n    /**\n     * Get a timeline for a child, synced timeline.\n     * @method PIXI.animate.MovieClip#_getChildTimeline\n     * @private\n     * @param {PIXI.animate.MovieClip} instance\n     * @return {PIXI.animate.Timeline}\n     */\n    _getChildTimeline(instance) {\n        for (let i = this._timelines.length - 1; i >= 0; --i) {\n            if (this._timelines[i].target === instance) {\n                return this._timelines[i];\n            }\n        }\n        let timeline = new Timeline(instance);\n        this._timelines.push(timeline);\n        return timeline;\n    }\n\n    /**\n     * Add mask or masks\n     * @method PIXI.animate.MovieClip#addTimedMask\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    addTimedMask(instance, keyframes) {\n        for (let i in keyframes) {\n            this.addKeyframe(instance, {\n                m: keyframes[i]\n            }, parseInt(i, 10));\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(this.currentFrame, this.currentFrame, true);\n        return this;\n    }\n\n    /**\n     * Shortcut alias for `addTimedMask`\n     * @method PIXI.animate.MovieClip#am\n     * @param {PIXI.DisplayObject} instance Instance to mask\n     * @param {Object} keyframes The map of frames to mask objects\n     * @return {PIXI.animate.MovieClip} instance of clip for chaining\n     */\n    am(instance, keyframes) {\n        return this.addTimedMask(instance, keyframes);\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addTween\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTween(instance, properties, startFrame, duration, ease) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addTween(properties, startFrame, duration, ease);\n        this._autoExtend(startFrame + duration);\n        return this;\n    }\n\n    /**\n     * Add a tween to the clip\n     * @method PIXI.animate.MovieClip#addKeyframe\n     * @param {PIXI.DisplayObject} instance The clip to tween\n     * @param {Object} properties The property or property to tween\n     * @param {int} startFrame The frame to start tweening\n     * @param {int} [duration=0] Number of frames to tween. If 0, then the properties are set\n     *                           with no tweening.\n     * @param {Function} [ease] An optional easing function that takes the tween time from 0-1.\n     * @return {PIXI.animate.MovieClip}\n     */\n    addKeyframe(instance, properties, startFrame) {\n\n        let timeline = this._getChildTimeline(instance);\n        this._parseProperties(properties);\n        timeline.addKeyframe(properties, startFrame);\n        this._autoExtend(startFrame);\n        return this;\n    }\n\n    /**\n     * Alias for method `addTimedChild`\n     * @method PIXI.animate.MovieClip#at\n     * @return {PIXI.animate.MovieClip}\n     */\n    at(instance, startFrame, duration, keyframes) {\n        return this.addTimedChild(instance, startFrame, duration, keyframes);\n    }\n\n    /**\n     * Add a child to show for a certain number of frames before automatic removal.\n     * @method PIXI.animate.MovieClip#addTimedChild\n     * @param {PIXI.DisplayObject} instance The clip to show\n     * @param {int} startFrame The starting frame\n     * @param {int} [duration=1] The number of frames to display the child before removing it.\n     * @param {String|Array} [keyframes] The collection of static keyframes to add\n     * @return {PIXI.animate.MovieClip}\n     */\n    addTimedChild(instance, startFrame, duration, keyframes) {\n\n        if (startFrame === undefined) // jshint ignore:line\n        {\n            startFrame = 0;\n        }\n        if (duration === undefined || duration < 1) // jshint ignore:line\n        {\n            duration = this._totalFrames || 1;\n        }\n\n        // Add the starting offset for synced movie clips\n        if (instance.mode === MovieClip.SYNCHED) {\n            instance.parentStartPosition = startFrame;\n        }\n\n        //add tweening info about this child's presence on stage\n        //when the child is (re)added, if it has 'autoReset' set to true, then it\n        //should be set back to frame 0\n        let timeline, i;\n        //get existing timeline\n        for (i = this._timedChildTimelines.length - 1; i >= 0; --i) {\n            if (this._timedChildTimelines[i].target === instance) {\n                timeline = this._timedChildTimelines[i];\n                break;\n            }\n        }\n        //if there wasn't one, make a new one\n        if (!timeline) {\n            timeline = [];\n            timeline.target = instance;\n            this._timedChildTimelines.push(timeline);\n        }\n\n        // Fill the timeline with keyframe booleans\n        utils.fillFrames(timeline, startFrame, duration);\n\n        // Update the total frames if the instance extends our current\n        // total frames for this movieclip\n        if (this._totalFrames < startFrame + duration) {\n            this._totalFrames = startFrame + duration;\n        }\n\n        // Add the collection of keyframes\n        if (keyframes) {\n            if (typeof keyframes === \"string\") {\n                keyframes = utils.deserializeKeyframes(keyframes);\n            }\n            // Convert the keyframes object into\n            // individual properties\n            let lastFrame = {};\n            for (let i in keyframes) {\n                lastFrame = Object.assign({}, lastFrame, keyframes[i]);\n                this.addKeyframe(instance, lastFrame, parseInt(i, 10));\n            }\n            this._getChildTimeline(instance)\n                .extendLastFrame(startFrame + duration);\n        }\n\n        // Set the initial position/add\n        this._setTimelinePosition(startFrame, this.currentFrame, true);\n\n        return this;\n    }\n\n    /**\n     * Short cut for `addAction`\n     * @method PIXI.animate.MovieClip#aa\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    aa(callback, startFrame) {\n        return this.addAction(callback, startFrame);\n    }\n\n    /**\n     * Handle frame actions, callback is bound to the instance of the MovieClip.\n     * @method PIXI.animate.MovieClip#addAction\n     * @param {Function} callback The clip call on a certain frame\n     * @param {int|String} startFrame The starting frame index or label\n     * @return {PIXI.animate.MovieClip}\n     */\n    addAction(callback, startFrame) {\n\n        if (typeof startFrame === 'string') {\n            const index = this._labelDict[startFrame];\n            if (index === undefined) {\n                throw `The label '${startFrame}' does not exist on this timeline`;\n            }\n            startFrame = index;\n        }\n\n        let actions = this._actions;\n        //ensure that the movieclip timeline is long enough to support the target frame\n        if (actions.length <= startFrame) {\n            actions.length = startFrame + 1;\n        }\n        if (this._totalFrames < startFrame) {\n            this._totalFrames = startFrame;\n        }\n        //add the action\n        if (actions[startFrame]) {\n            actions[startFrame].push(callback);\n        } else {\n            actions[startFrame] = [callback];\n        }\n        return this;\n    }\n\n    /**\n     * Short cut for `playSound`\n     * @method PIXI.animate.MovieClip#ps\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    ps(alias, loop) {\n        return this.playSound(alias, loop);\n    }\n\n    /**\n     * Handle sounds.\n     * @method PIXI.animate.MovieClip#playSound\n     * @param {String} alias The name of the Sound\n     * @param {Boolean} [loop=false] The loop property of the sound\n     * @param {MovieClip} context The MovieClip the sound originates from\n     * @return {PIXI.animate.MovieClip}\n     */\n    playSound(alias, loop) {\n        PIXI.animate.sound.emit('play', alias, !!loop, this);\n        return this;\n    }\n\n    /**\n     * Sets paused to false.\n     * @method PIXI.animate.MovieClip#play\n     */\n    play() {\n        this.paused = false;\n    }\n\n    /**\n     * Sets paused to true.\n     * @method PIXI.animate.MovieClip#stop\n     */\n    stop() {\n        this.paused = true;\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to false.\n     * @method PIXI.animate.MovieClip#gotoAndPlay\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     */\n    gotoAndPlay(positionOrLabel) {\n        this.paused = false;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Advances this movie clip to the specified position or label and sets paused to true.\n     * @method PIXI.animate.MovieClip#gotoAndStop\n     * @param {String|Number} positionOrLabel The animation or frame name to go to.\n     */\n    gotoAndStop(positionOrLabel) {\n        this.paused = true;\n        this._goto(positionOrLabel);\n    }\n\n    /**\n     * Get the close parent with a valid framerate. If no parent, returns the default framerate.\n     * @name PIXI.animate.MovieClip#parentFramerate\n     * @type {Number}\n     * @readOnly\n     */\n    get parentFramerate() {\n        let o = this,\n            fps = o._framerate;\n        while ((o = o.parent) && !fps) {\n            if (o.mode === MovieClip.INDEPENDENT) {\n                fps = o._framerate;\n            }\n        }\n        return fps || MovieClip.DEFAULT_FRAMERATE;\n    }\n\n    /**\n     * Advances the playhead. This occurs automatically each tick by default.\n     * @method PIXI.animate.MovieClip#advance\n     * @param [time] {Number} The amount of time in seconds to advance by. Only applicable if framerate is set.\n     */\n    advance(time) {\n\n        // Handle any other cases where starting to play\n        // and no framerate has been set yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        if (time) {\n            this._t += time;\n        }\n        if (this._t > this._duration) {\n            this._t = this.loop ? this._t - this._duration : this._duration;\n        }\n        //add a tiny amount to account for potential floating point errors\n        this.currentFrame = Math.floor(this._t * this._framerate + 0.00000001);\n        //final error checking\n        if (this.currentFrame >= this._totalFrames) {\n            this.currentFrame = this._totalFrames - 1;\n        }\n        let afterUpdateOnce;\n        if (this._beforeUpdate) {\n            afterUpdateOnce = this._beforeUpdate(this);\n        }\n        //update all tweens & actions in the timeline\n        this._updateTimeline();\n\n        // Do the animator callback here\n        if (afterUpdateOnce) {\n            afterUpdateOnce();\n        }\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_goto\n     * @param {String|Number} positionOrLabel The animation name or frame number to go to.\n     * @protected\n     */\n    _goto(positionOrLabel) {\n        let pos = typeof positionOrLabel === 'string' ? this._labelDict[positionOrLabel] : positionOrLabel;\n        if (pos === undefined) // jshint ignore:line\n        {\n            return;\n        }\n        // prevent _updateTimeline from overwriting the new position because of a reset:\n        this._prevPos = NaN;\n        this.currentFrame = pos;\n\n        // Handle the case where trying to play but haven't\n        // added to the stage yet\n        if (!this._framerate) {\n            this.framerate = this.parentFramerate;\n        }\n\n        //update the elapsed time if a time based movieclip\n        if (this._framerate > 0) {\n            this._t = pos / this._framerate;\n        } else {\n            this._t = 0;\n        }\n        this._updateTimeline();\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_reset\n     * @private\n     */\n    _reset() {\n        this._prevPos = -1;\n        this._t = 0;\n        this.currentFrame = 0;\n    }\n\n    /**\n     * @method PIXI.animate.MovieClip#_updateTimeline\n     * @protected\n     */\n    _updateTimeline() {\n        let synched = this.mode !== MovieClip.INDEPENDENT;\n\n        if (synched) {\n            this.currentFrame = this.startPosition + (this.mode === MovieClip.SINGLE_FRAME ? 0 : this._synchOffset);\n            if (this.currentFrame >= this._totalFrames) {\n                this.currentFrame %= this._totalFrames;\n            }\n        }\n\n        if (this._prevPos === this.currentFrame) {\n            return;\n        }\n\n        // update timeline position, ignoring actions if this is a graphic.\n        this._setTimelinePosition(this._prevPos, this.currentFrame, synched ? false : this.actionsEnabled);\n\n        this._prevPos = this.currentFrame;\n    }\n\n    /**\n     * Set the timeline position\n     * @method PIXI.animate.MovieClip#_setTimelinePosition\n     * @protected\n     * @param {int} startFrame\n     * @param {int} currentFrame\n     * @param {Boolean} doActions\n     */\n    _setTimelinePosition(startFrame, currentFrame, doActions) {\n        //handle all tweens\n        let i, j, length, _timelines = this._timelines;\n        for (i = _timelines.length - 1; i >= 0; --i) {\n            let timeline = _timelines[i];\n            for (j = 0, length = timeline.length; j < length; ++j) {\n                let tween = timeline[j];\n                //if the tween contains part of the timeline that we are travelling through\n                if (currentFrame >= tween.startFrame &&\n                    currentFrame <= tween.endFrame) {\n                    // set the position within that tween\n                    //and break the loop to move onto the next timeline\n                    tween.setPosition(currentFrame);\n                    break;\n                }\n            }\n        }\n\n        let timedChildTimelines = this._timedChildTimelines;\n        let depthSorted = this._depthSorted;\n        for (i = 0, length = timedChildTimelines.length; i < length; ++i) {\n            let target = timedChildTimelines[i].target;\n            let shouldBeChild = timedChildTimelines[i][currentFrame];\n            //if child should be on stage and is not:\n            if (shouldBeChild) {\n                // Add to the depthSorted object so we can\n                // check that items are property drawn later\n                depthSorted.push(target);\n                if (target.parent !== this) {\n                    // add the target if it's not there already\n                    this.addChild(target);\n                    if (target.mode === MovieClip.INDEPENDENT && target.autoReset) {\n                        target._reset();\n                    }\n                }\n            } else if (!shouldBeChild && target.parent === this) {\n                this.removeChild(target);\n            }\n        }\n\n        // Properly depth sort the children\n        for (i = 0, length = depthSorted.length; i < length; i++) {\n            let target = depthSorted[i];\n            let currentIndex = this.children.indexOf(target);\n            if (currentIndex !== i) {\n                this.addChildAt(target, i);\n            }\n        }\n\n        // Clear the temporary depth sorting array\n        depthSorted.length = 0;\n\n        //go through all children and update synched movieclips that are not single frames\n        let children = this.children,\n            child;\n        for (i = 0, length = children.length; i < length; ++i) {\n            child = children[i];\n            if (child.mode === MovieClip.SYNCHED) {\n                child._synchOffset = currentFrame - child.parentStartPosition;\n                child._updateTimeline();\n            }\n        }\n\n        //handle actions\n        if (doActions) {\n            let actions = this._actions;\n            //handle looping around\n            let needsLoop = false;\n            if (currentFrame < startFrame) {\n                length = actions.length;\n                needsLoop = true;\n            } else {\n                length = Math.min(currentFrame + 1, actions.length);\n            }\n            for (i = startFrame >= 0 ? startFrame + 1 : currentFrame; i < length; ++i) {\n                if (actions[i]) {\n                    let frameActions = actions[i];\n                    for (j = 0; j < frameActions.length; ++j) {\n                        frameActions[j].call(this);\n                    }\n                }\n                //handle looping around\n                if (needsLoop && i === length - 1) {\n                    i = 0;\n                    length = currentFrame + 1;\n                    needsLoop = false;\n                }\n            }\n        }\n    }\n\n    destroy(destroyChildren) {\n        if (this._tickListener) {\n            SharedTicker.remove(this._tickListener);\n            this._tickListener = null;\n        }\n        const hiddenChildren = [];\n        let timelines = this._timelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                hiddenChildren.push(timeline.target);\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        timelines = this._timedChildTimelines;\n        if (timelines) {\n            for (let i = 0; i < timelines.length; i++) {\n                const timeline = timelines[i];\n                if (hiddenChildren.indexOf(timeline.target) < 0) {\n                    hiddenChildren.push(timeline.target);\n                }\n                timeline._currentProps = null;\n                timeline.length = 0;\n            }\n        }\n        // Destroy all the children\n        for (let i = 0; i < hiddenChildren.length; i++) {\n            // Don't destroy children in the display list\n            if (this.children.indexOf(hiddenChildren[i]) < 0) {\n                hiddenChildren[i].destroy(destroyChildren);\n            }\n        }\n        hiddenChildren.length = 0;\n        this._actions = null;\n        this._timelines = null;\n        this._depthSorted = null;\n        this._timedChildTimelines = null;\n        this._beforeUpdate = null;\n        this._labels = null;\n        this._labelDict = null;\n        super.destroy(destroyChildren);\n    }\n}\n\n/**\n * The MovieClip will advance independently of its parent, even if its parent is paused.\n * This is the default mode.\n * @name PIXI.animate.MovieClip.INDEPENDENT\n * @static\n * @type String\n * @default 0\n * @readonly\n */\nMovieClip.INDEPENDENT = 0;\n\n/**\n * The MovieClip will only display a single frame (as determined by the startPosition property).\n * @name PIXI.animate.MovieClip.SINGLE_FRAME\n * @static\n * @type String\n * @default 1\n * @readonly\n */\nMovieClip.SINGLE_FRAME = 1;\n\n/**\n * The MovieClip will be advanced only when its parent advances and will be synched to the position of\n * the parent MovieClip.\n * @name PIXI.animate.MovieClip.SYNCHED\n * @static\n * @type String\n * @default 2\n * @readonly\n */\nMovieClip.SYNCHED = 2;\n\n\n/**\n * The default framerate if none is specified or there's not parent clip with a framerate.\n * @name PIXI.animate.MovieClip.DEFAULT_FRAMERATE\n * @static\n * @type Number\n * @default 24\n * @readonly\n */\nMovieClip.DEFAULT_FRAMERATE = 24;\n\n/**\n * Extend a container\n * @method PIXI.animate.MovieClip.extend\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\n/**\n * Extend a container (alias for `extend`)\n * @method PIXI.animate.MovieClip.e\n * @static\n * @param {PIXI.animate.MovieClip} child The child function\n * @return {PIXI.animate.MovieClip} The child\n */\nMovieClip.extend = MovieClip.e = function(child) {\n    child.prototype = Object.create(MovieClip.prototype);\n    child.prototype.__parent = MovieClip.prototype;\n    child.prototype.constructor = child;\n    return child;\n};\n\n// Assign to namespace\nexport default MovieClip;","import load from './load';\nimport sound from './sound';\n\n/**\n * Extends the PIXI.Application class to provide easy loading.\n * ```\n * const scene = new PIXI.animate.Scene();\n * scene.load(lib.StageName);\n * ```\n * @class Scene\n * @memberof PIXI.animate\n * @param {Number} [width=800] Stage width\n * @param {Number} [height=600] Stage height\n * @param {Object} [renderOptions] See PIXI.Application for more info.\n * @param {Boolean} [noWebGL=false] Disable WebGL\n */\nclass Scene extends PIXI.Application {\n\n\tconstructor(width, height, renderOptions, noWebGL) {\n\t\tsuper(width, height, renderOptions, noWebGL);\n\n\t\t/**\n\t\t * Reference to the global sound object\n\t\t * @name PIXI.animate.Scene#sound\n\t\t * @type {PIXI.animate.sound}\n\t\t * @readOnly\n\t\t */\n\t\tthis.sound = sound;\n\n\t\t/**\n\t\t * The stage object created.\n\t\t * @name PIXI.animate.Scene#instance\n\t\t * @type {PIXI.animate.MovieClip}\n\t\t * @readOnly\n\t\t */\n\t\tthis.instance = null;\n\t}\n\n\t/**\n\t * Load a stage scene and add it to the stage.\n\t * @method PIXI.animate.Scene#load\n\t * @param {Function} StageRef Reference to the stage class.\n\t * @param {Function} [complete] Callback when finished loading.\n\t * @param {String} [basePath] Optional base directory to prepend to assets.\n\t * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n\t */\n\tload(StageRef, complete, basePath) {\n\t\treturn load(StageRef, this.stage, (instance) => {\n\t\t\tthis.instance = instance;\n\t\t\tif (complete) {\n\t\t\t\tcomplete(instance);\n\t\t\t}\n\t\t}, basePath);\n\t}\n\n\t/**\n\t * Destroy and don't use after calling.\n\t * @method PIXI.animate.Scene#destroy\n\t * @param {Boolean} [removeView=false] `true` to remove canvas element.\n\t */\n\tdestroy(removeView) {\n\t\tif (this.instance) {\n\t\t\tthis.instance.destroy(true);\n\t\t\tthis.instance = null;\n\t\t}\n\t\tsuper.destroy(removeView);\n\t}\n}\n\nexport default Scene;","import utils from './utils';\n\n/**\n * Contains the collection of graphics data\n * @memberof PIXI.animate\n * @class ShapesCache\n */\nconst ShapesCache = {};\n\n/**\n * Add an item or itesm to the cache\n * @method PIXI.animate.ShapesCache.add\n * @static\n * @param {String} prop  The id of graphic or the map of graphics to add\n * @param {String|Array<Array>} items Collection of draw commands\n */\nObject.defineProperty(ShapesCache, 'add', {\n    enumerable: false,\n    value: function(prop, items) {\n\n        // Decode string to map of files\n        if (typeof items === \"string\") {\n            items = utils.deserializeShapes(items);\n        }\n\n        // Convert all hex string colors (animate) to int (pixi.js)\n        for (let i = 0; i < items.length; i++) {\n            let item = items[i];\n            for (let j = 0; j < item.length; j++) {\n                let arg = item[j];\n                if (typeof arg === 'string' && arg[0] === '#') {\n                    item[j] = utils.hexToUint(arg);\n                }\n            }\n        }\n        ShapesCache[prop] = items;\n    }\n});\n\n\n/**\n * Get the graphic from cache\n * @method  PIXI.animate.ShapesCache.fromCache\n * @static\n * @param  {String} id The cache id\n * @return {Array} Series of graphic draw commands\n */\nObject.defineProperty(ShapesCache, 'fromCache', {\n    enumerable: false,\n    value: function(id) {\n        return ShapesCache[id] || null;\n    }\n});\n\n/**\n * Remove the graphic from cache\n * @method  PIXI.animate.ShapesCache.remove\n * @static\n * @param  {String|Object} id The cache id or map\n */\nObject.defineProperty(ShapesCache, 'remove', {\n    enumerable: false,\n    value: function(id) {\n        if (typeof id === \"object\") {\n            for (let name in id) {\n                ShapesCache.remove(name);\n            }\n            return;\n        }\n        if (ShapesCache[id]) {\n            ShapesCache[id].length = 0;\n            delete ShapesCache[id];\n        }\n    }\n});\n\n/**\n * Remove all graphics from cache\n * @method  PIXI.animate.ShapesCache.removeAll\n * @static\n */\nObject.defineProperty(ShapesCache, 'removeAll', {\n    enumerable: false,\n    value: function() {\n        for (let id in ShapesCache) {\n            ShapesCache.remove(id);\n        }\n    }\n});\n\n// Assign to namespace\nexport default ShapesCache;","import ShapesCache from './ShapesCache';\n\n/**\n * The middleware for PIXI's ResourceLoader to be able to \n * load Flash symbols such as graphics and images.\n * @memberof PIXI.animate\n * @class SymbolLoader\n * @private\n */\nlet SymbolLoader = function() {\n    return function(resource, next) {\n        let url = resource.url;\n        let data = resource.data;\n\n        if (url.search(/\\.shapes\\.(json|txt)$/i) > -1) {\n            ShapesCache.add(resource.name, data);\n        } else if (data.nodeName && data.nodeName === 'IMG') {\n            // Add individual images to the texture cache by their\n            // short symbol name, not the URL\n            PIXI.Texture.addTextureToCache(\n                PIXI.Texture.fromFrame(url),\n                resource.name\n            );\n        }\n        next();\n    };\n};\n\n// Assign to the loader\nPIXI.loaders.Loader.addPixiMiddleware(SymbolLoader);\n\nexport default SymbolLoader;","import Tween from './Tween';\n\n/**\n * The Timeline class represents a\n * @memberof PIXI.animate\n * @class Timeline\n * @param {PIXI.DisplayObject} Target The target for this string of tweens.\n * @extends Array\n * @constructor\n */\nconst Timeline = function(target) {\n    Array.call(this);\n\n    /**\n     * The target DisplayObject.\n     * @name PIXI.animate.Timeline#target\n     * @type {PIXI.DisplayObject}\n     */\n    this.target = target;\n\n    /**\n     * Current properties in the tween, to make building the timeline more\n     * efficient.\n     * @name PIXI.animate.Timeline#_currentProps\n     * @type {Object}\n     * @private\n     */\n    this._currentProps = {};\n};\n\nconst p = Timeline.prototype = Object.create(Array.prototype);\n\n/**\n * Adds one or more tweens (or timelines) to this timeline. The tweens will be paused (to remove them from the normal ticking system)\n * and managed by this timeline. Adding a tween to multiple timelines will result in unexpected behaviour.\n * @method PIXI.animate.Timeline#addTween\n * @param tween The tween(s) to add. Accepts multiple arguments.\n * @return Tween The first tween that was passed in.\n */\np.addTween = function(properties, startFrame, duration, ease) {\n    this.extendLastFrame(startFrame - 1);\n    //ownership of startProps is passed to the new Tween - this object should not be reused\n    let startProps = {};\n    let prop;\n    //figure out what the starting values for this tween should be\n    for (prop in properties) {\n        //if we have already set that property in an earlier tween, use the ending value\n        if (this._currentProps.hasOwnProperty(prop)) {\n            startProps[prop] = this._currentProps[prop];\n        }\n        //otherwise, get the current value\n        else {\n            let startValue = startProps[prop] = this.getPropFromShorthand(prop);\n            //go through previous tweens to set the value so that when the timeline loops\n            //around, the values are set properly - having each tween know what came before\n            //allows us to set to a specific frame without running through the entire timeline\n            for (let i = this.length - 1; i >= 0; --i) {\n                this[i].startProps[prop] = startValue;\n                this[i].endProps[prop] = startValue;\n            }\n        }\n    }\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, properties, startFrame, duration, ease);\n    this.push(tween);\n    //update starting values for the next tween - if tweened values included 'p', then Tween\n    //parsed that to add additional data that is required\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Add a single keyframe that doesn't tween.\n * @method PIXI.animate.Timeline#addKeyframe\n * @param {Object} properties The properties to set.\n * @param {int} startFrame The starting frame index.\n */\np.addKeyframe = function(properties, startFrame) {\n    this.extendLastFrame(startFrame - 1);\n    let startProps = Object.assign({}, this._currentProps, properties);\n    //create the new Tween and add it to the list\n    let tween = new Tween(this.target, startProps, null, startFrame, 0);\n    this.push(tween);\n    Object.assign(this._currentProps, tween.endProps);\n};\n\n/**\n * Extend the last frame of the tween.\n * @method PIXI.animate.Timeline#extendLastFrame\n * @param {int} endFrame The ending frame index.\n */\np.extendLastFrame = function(endFrame) {\n    if (this.length) {\n        let prevTween = this[this.length - 1];\n        if (prevTween.endFrame < endFrame) {\n            if (prevTween.isTweenlessFrame) {\n                prevTween.endFrame = endFrame;\n            } else {\n                this.addKeyframe(\n                    this._currentProps,\n                    prevTween.endFrame + 1,\n                    endFrame - prevTween.endFrame + 1\n                );\n            }\n        }\n    }\n};\n\n/**\n * Get the value for a property\n * @method PIXI.animate.Timeline#getPropFromShorthand\n * @param {string} prop\n */\np.getPropFromShorthand = function(prop) {\n    const target = this.target;\n    switch (prop) {\n        case 'x':\n            return target.position.x;\n        case 'y':\n            return target.position.y;\n        case 'sx':\n            return target.scale.x;\n        case 'sy':\n            return target.scale.y;\n        case 'kx':\n            return target.skew.x;\n        case 'ky':\n            return target.skew.y;\n        case 'r':\n            return target.rotation;\n        case 'a':\n            return target.alpha;\n        case 'v':\n            return target.visible;\n        case 'm':\n            return target.mask;\n            // case 't':\n            //   return target.tint;\n            //not sure if we'll actually handle graphics this way?\n            //g: return null;\n    }\n    return null;\n};\n\n// Assign to namespace\nexport default Timeline;","/**\n * Provide timeline playback of movieclip\n * @memberof PIXI.animate\n * @class Tween\n * @constructor\n * @param {PIXI.animate.MovieClip} target The target to play\n * @param {Object} startProps The starting properties\n * @param {Object} endProps The ending properties\n * @param {int} duration Number oframes to tween\n * @param {Function} [ease] Ease function to use\n */\n\nclass Tween {\n\n    constructor(target, startProps, endProps, startFrame, duration, ease) {\n\n        /**\n         * target display object\n         * @name PIXI.animate.Tween#target\n         * @type {Object}\n         */\n        this.target = target;\n\n        /**\n         * properties at the start of the tween\n         * @type {Object}\n         * @name PIXI.animate.Tween#startProps\n         */\n        this.startProps = startProps;\n\n        /**\n         * properties at the end of the tween, as well as any properties that are set\n         * instead of tweened\n         * @type {Object}\n         * @name PIXI.animate.Tween#endProps\n         */\n        this.endProps = {};\n\n        /**\n         * duration of tween in frames. For a keyframe with no tweening, the duration will be 0.\n         * @type {int}\n         * @name PIXI.animate.Tween#duration\n         */\n        this.duration = duration;\n\n        /**\n         * The frame that the tween starts on\n         * @type {int}\n         * @name PIXI.animate.Tween#startFrame\n         */\n        this.startFrame = startFrame;\n\n        /**\n         * the frame that the tween ends on\n         * @type {int}\n         * @name PIXI.animate.Tween#endFrame\n         */\n        this.endFrame = startFrame + duration;\n\n        /**\n         * easing function to use, if any\n         * @type {Function}\n         * @name PIXI.animate.Tween#ease\n         */\n        this.ease = ease;\n\n        /**\n         * If we don't tween.\n         * @type {Boolean}\n         * @name PIXI.animate.Tween#isTweenlessFrame\n         */\n        this.isTweenlessFrame = !endProps;\n\n\n        let prop;\n        if (endProps) {\n            //make a copy to safely include any unchanged values from the start of the tween\n            for (prop in endProps) {\n                this.endProps[prop] = endProps[prop];\n            }\n        }\n\n        //copy in any starting properties don't change\n        for (prop in startProps) {\n            if (!this.endProps.hasOwnProperty(prop)) {\n                this.endProps[prop] = startProps[prop];\n            }\n        }\n    }\n\n    /**\n     * Set the current frame.\n     * @method PIXI.animate.Tween#setPosition\n     * @param {int} currentFrame\n     */\n    setPosition(currentFrame) {\n        //if this is a single frame with no tweening, or at the end of the tween, then\n        //just speed up the process by setting values\n        if (currentFrame >= this.endFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        if (this.isTweenlessFrame) {\n            this.setToEnd();\n            return;\n        }\n\n        let time = (currentFrame - this.startFrame) / this.duration;\n        if (this.ease) {\n            time = this.ease(time);\n        }\n        let target = this.target;\n        let startProps = this.startProps;\n        let endProps = this.endProps;\n        for (let prop in endProps) {\n            let lerp = props[prop];\n            if (lerp) {\n                setPropFromShorthand(target, prop, lerp(startProps[prop], endProps[prop], time));\n            } else {\n                setPropFromShorthand(target, prop, startProps[prop]);\n            }\n        }\n    }\n\n    /**\n     * Set to the end position\n     * @method PIXI.animate.Tween#setToEnd\n     */\n    setToEnd() {\n        let endProps = this.endProps;\n        let target = this.target;\n        for (let prop in endProps) {\n            setPropFromShorthand(target, prop, endProps[prop]);\n        }\n    }\n}\n\n//standard tweening\nfunction lerpValue(start, end, t) {\n    return start + (end - start) * t;\n}\n\nconst props = {\n    //position\n    x: lerpValue,\n    y: lerpValue,\n    //scale\n    sx: lerpValue,\n    sy: lerpValue,\n    //skew\n    kx: lerpValue,\n    ky: lerpValue,\n    //rotation\n    r: lerpRotation,\n    //alpha\n    a: lerpValue,\n    //tinting\n    // t: lerpColor,\n    t: null,\n    //values to be set\n    v: null, //visible\n    c: null, //colorTransform\n    m: null, //mask\n    g: null //not sure if we'll actually handle graphics this way?\n};\n\n//split r, g, b into separate values for tweening\n/*function lerpColor(start, end, t)\n{\n    //split start color into components\n    let sR = start >> 16 & 0xFF;\n    let sG = start >> 8 & 0xFF;\n    let sB = start & 0xFF;\n    //split end color into components\n    let eR = end >> 16 & 0xFF;\n    let eG = end >> 8 & 0xFF;\n    let eB = end & 0xFF;\n    //lerp red\n    let r = sR + (eR - sR) * percent;\n    //clamp red to valid values\n    if (r < 0)\n        r = 0;\n    else if (r > 255)\n        r = 255;\n    //lerp green\n    let g = sG + (eG - sG) * percent;\n    //clamp green to valid values\n    if (g < 0)\n        g = 0;\n    else if (g > 255)\n        g = 255;\n    //lerp blue\n    let b = sB + (eB - sB) * percent;\n    //clamp blue to valid values\n    if (b < 0)\n        b = 0;\n    else if (b > 255)\n        b = 255;\n\n    let combined = (r << 16) | (g << 8) | b;\n    return combined;\n}*/\n\nconst PI = Math.PI;\nconst TWO_PI = PI * 2;\n\n//handle 355 -> 5 degrees only going through a 10 degree change instead of\n//the long way around\n//Math from http://stackoverflow.com/a/2708740\nfunction lerpRotation(start, end, t) {\n    let difference = Math.abs(end - start);\n    if (difference > PI) {\n        // We need to add on to one of the values.\n        if (end > start) {\n            // We'll add it on to start...\n            start += TWO_PI;\n        } else {\n            // Add it on to end.\n            end += PI + TWO_PI;\n        }\n    }\n\n    // Interpolate it.\n    let value = (start + ((end - start) * t));\n\n    // wrap to 0-2PI\n    /*if (value >= 0 && value <= TWO_PI)\n        return value;\n    return value % TWO_PI;*/\n\n    //just return, as it's faster\n    return value;\n}\n\nfunction setPropFromShorthand(target, prop, value) {\n    switch (prop) {\n        case \"x\":\n            target.transform.position.x = value;\n            break;\n        case \"y\":\n            target.transform.position.y = value;\n            break;\n        case \"sx\":\n            target.transform.scale.x = value;\n            break;\n        case \"sy\":\n            target.transform.scale.y = value;\n            break;\n        case \"kx\":\n            target.transform.skew.x = value;\n            break;\n        case \"ky\":\n            target.transform.skew.y = value;\n            break;\n        case \"r\":\n            target.transform.rotation = value;\n            break;\n        case \"a\":\n            target.alpha = value;\n            break;\n        case \"t\":\n            target.i(value); // i = setTint\n            break;\n        case \"c\":\n            target.c.apply(target, value); // c = setColorTransform\n            break;\n        case \"v\":\n            target.visible = value;\n            break;\n        case \"m\":\n            target.ma(value); // ma = setMask\n            break;\n    }\n}\n\n// Assign to namespace\nexport default Tween;","import load from './load';\nimport sound from './sound';\nimport utils from './utils';\nimport MovieClip from './MovieClip';\nimport Scene from './Scene';\nimport ShapesCache from './ShapesCache';\nimport SymbolLoader from './SymbolLoader';\nimport Timeline from './Timeline';\nimport Tween from './Tween';\nimport Animator from './Animator';\nimport AnimatorTimeline from './AnimatorTimeline';\n\nconst VERSION = __VERSION__;\n\n/**\n * @namespace PIXI.animate\n */\nexport {\n    Animator,\n    AnimatorTimeline,\n    load,\n    sound,\n    utils,\n    MovieClip,\n    Scene,\n    ShapesCache,\n    SymbolLoader,\n    Timeline,\n    Tween,\n    VERSION\n};","// Configure PIXI Loader to handle audio files correctly\nconst Resource = PIXI.loaders.Resource;\nResource.setExtensionLoadType('wav', Resource.LOAD_TYPE.AUDIO);\nResource.setExtensionLoadType('mp3', Resource.LOAD_TYPE.AUDIO);\nResource.setExtensionLoadType('ogg', Resource.LOAD_TYPE.AUDIO);\n\n/**\n * Load the stage class and preload any assets\n * @method PIXI.animate.load\n * @param {Object} options Options for loading.\n * @param {Function} options.stage Reference to the stage class\n * @param {Object} [options.stage.assets] Assets used to preload\n * @param {PIXI.Container} options.parent The Container to auto-add the stage to.\n * @param {String} [options.basePath] Base root directory\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, function(instance){\n *     stage.addChild(instance);\n * });\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {Function} complete The callback function when complete.\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, stage);\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\n * @param {String} [basePath] Base root directory\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\n/**\n * Load the stage class and preload any assets\n * ```\n * let renderer = new PIXI.autoDetectRenderer(1280, 720);\n * let stage = new PIXI.Container();\n * PIXI.animate.load(lib.MyStage, stage);\n * function update() {\n *      renderer.render(stage);\n *      update();\n * }\n * update();\n * ```\n * @method PIXI.animate.load\n * @param {Function} StageRef Reference to the stage class.\n * @param {Object} [StageRef.assets] Assets used to preload.\n * @param {PIXI.Container} parent The Container to auto-add the stage to.\n * @param {Function} [complete] The callback function when complete.\n * @param {String} [basePath] Base root directory\n * @return {PIXI.loaders.Loader} instance of PIXI resource loader\n */\nconst load = function(options, parent, complete, basePath) {\n\n    // Support arguments (ref, complete, basePath)\n    if (typeof parent === \"function\") {\n        basePath = complete;\n        complete = parent;\n        parent = null;\n    } else {\n        if (typeof complete === \"string\") {\n            basePath = complete;\n            complete = null;\n        }\n    }\n\n    if (typeof options === \"function\") {\n        options = {\n            stage: options,\n            parent: parent,\n            basePath: basePath || \"\",\n            complete: complete\n        };\n    }\n\n    options = Object.assign({\n        stage: null,\n        parent: null,\n        basePath: '',\n        complete: null\n    }, options || {});\n\n    const loader = new PIXI.loaders.Loader();\n\n    function done() {\n        let instance = new options.stage();\n        if (options.parent) {\n            options.parent.addChild(instance);\n        }\n        if (options.complete) {\n            options.complete(instance, loader);\n        }\n    }\n\n    // Check for assets to preload\n    let assets = options.stage.assets || {};\n    if (assets && Object.keys(assets).length) {\n        // assetBaseDir can accept either with trailing slash or not\n        let basePath = options.basePath;\n        if (basePath) {\n            basePath += \"/\";\n        }\n        for (let id in assets) {\n            loader.add(id, basePath + assets[id]);\n        }\n        loader.once('complete', done).load();\n    } else {\n        // tiny case where there's only text and no shapes/animations\n        done();\n    }\n\n    return loader;\n};\n\nexport default load;","/**\n * @description Event emitter for all sound events. This emits a single\n * `play` event which contains the alias, loop and MovieClip which is playing\n * the sound.\n * @name PIXI.animate.sound\n * @type {EventEmitter}\n * @example\n * \n * PIXI.animate.sound.on('play', (alias, loop, context) => {\n *    // custom handle sounds being played\n *    // where 'alias' is the ID in stage assets\n * });\n */\nexport default new PIXI.utils.EventEmitter();","// If the movieclip plugin is installed\nlet _prepare = null;\n\n/**\n * @namespace PIXI.animate.utils\n * @description For keyframe conversions\n */\nexport default class AnimateUtils {\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @static\n     * @method PIXI.animate.utils.hexToUint\n     */\n    static hexToUint(hex) {\n        // Remove the hash\n        hex = hex.substr(1);\n\n        // Convert shortcolors fc9 to ffcc99\n        if (hex.length === 3) {\n            hex = hex.replace(/([a-f0-9])/g, '$1$1');\n        }\n        return parseInt(hex, 16);\n    }\n\n    /** \n     * Fill frames with booleans of true (showing) and false (hidden).\n     * @static\n     * @method PIXI.animate.utils.fillFrames\n     * @param {Array<Boolean>} timeline\n     * @param {int} startFrame The start frame when the timeline shows up\n     * @param {int} duration The length of showing\n     */\n    static fillFrames(timeline, startFrame, duration) {\n        //ensure that the timeline is long enough\n        const oldLength = timeline.length;\n        if (oldLength < startFrame + duration) {\n            timeline.length = startFrame + duration;\n            //fill any gaps with false to denote that the child should be removed for a bit\n            if (oldLength < startFrame) {\n                //if the browser has implemented the ES6 fill() function, use that\n                if (timeline.fill) {\n                    timeline.fill(false, oldLength, startFrame);\n                } else {\n                    //if we can't use fill, then do a for loop to fill it\n                    for (let i = oldLength; i < startFrame; ++i) {\n                        timeline[i] = false;\n                    }\n                }\n            }\n        }\n        //if the browser has implemented the ES6 fill() function, use that\n        if (timeline.fill) {\n            timeline.fill(true, startFrame, startFrame + duration);\n        } else {\n            const length = timeline.length;\n            //if we can't use fill, then do a for loop to fill it\n            for (let i = startFrame; i < length; ++i) {\n                timeline[i] = true;\n            }\n        }\n    }\n\n    /**\n     * Convert serialized array into keyframes\n     * `\"0x100y100 1x150\"` to: `{ \"0\": {\"x\":100, \"y\": 100}, \"1\": {\"x\": 150} }`\n     * @static\n     * @method PIXI.animate.utils.deserializeKeyframes\n     * @param {String} keyframes\n     * @param {Object} Resulting keyframes\n     */\n    static deserializeKeyframes(keyframes) {\n        let result = {};\n        let i = 0;\n        let keysMap = {\n            X: 'x', // x position\n            Y: 'y', // y position\n            A: 'sx', // scale x\n            B: 'sy', // scale y\n            C: 'kx', // skew x\n            D: 'ky', // skew y\n            R: 'r', // rotation\n            L: 'a', // alpha\n            T: 't', // tint\n            F: 'c', // colorTransform\n            V: 'v' // visibility\n        };\n        let c,\n            buffer = '',\n            isFrameStarted = false,\n            prop,\n            frame = {};\n\n        while (i <= keyframes.length) {\n            c = keyframes[i];\n            if (keysMap[c]) {\n                if (!isFrameStarted) {\n                    isFrameStarted = true;\n                    result[buffer] = frame;\n                }\n                if (prop) {\n                    frame[prop] = this.parseValue(prop, buffer);\n                }\n                prop = keysMap[c];\n                buffer = '';\n                i++;\n            }\n            // Start a new prop\n            else if (!c || c === ' ') {\n                i++;\n                frame[prop] = this.parseValue(prop, buffer);\n                buffer = '';\n                prop = null;\n                frame = {};\n                isFrameStarted = false;\n            } else {\n                buffer += c;\n                i++;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Convert serialized shapes into draw commands for PIXI.Graphics.\n     * @static\n     * @method PIXI.animate.utils.deserializeShapes\n     * @param {String} str\n     * @param {Array} Resulting shapes map\n     */\n    static deserializeShapes(str) {\n        const result = [];\n        // each shape is a new line\n        let shapes = str.split(\"\\n\");\n        let isCommand = /^[a-z]{1,2}$/;\n        for (let i = 0; i < shapes.length; i++) {\n            let shape = shapes[i].split(' '); // arguments are space separated\n            for (let j = 0; j < shape.length; j++) {\n                // Convert all numbers to floats, ignore colors\n                let arg = shape[j];\n                if (arg[0] !== '#' && !isCommand.test(arg)) {\n                    shape[j] = parseFloat(arg);\n                }\n            }\n            result.push(shape);\n        }\n        return result;\n    }\n\n    /** \n     * Parse the value of the compressed keyframe.\n     * @method PIXI.animate.utils.parseValue\n     * @static\n     * @private\n     * @param {String} prop The property key\n     * @param {String} buffer The contents\n     * @return {*} The parsed value\n     */\n    static parseValue(prop, buffer) {\n        switch (prop) {\n            // Color transforms are parsed as an array\n            case 'c':\n                {\n                    buffer = buffer.split(',');\n                    buffer.forEach(function(val, i, buffer) {\n                        buffer[i] = parseFloat(val);\n                    });\n                    return buffer;\n                }\n                // Tint value should not be converted\n                // can be color uint or string\n            case 't':\n                {\n                    return buffer;\n                }\n                // The visiblity parse as boolean\n            case 'v':\n                {\n                    return !!parseInt(buffer);\n                }\n                // Everything else parse a floats\n            default:\n                {\n                    return parseFloat(buffer);\n                }\n        }\n    }\n\n    /** \n     * Upload all the textures and graphics to the GPU. \n     * @method PIXI.animate.utils.upload\n     * @static\n     * @param {PIXI.WebGLRenderer} renderer Render to upload to\n     * @param {PIXI.DisplayObject} clip MovieClip to upload\n     * @param {function} done When complete\n     */\n    static upload(renderer, displayObject, done) {\n        if (!_prepare) {\n            _prepare = renderer.plugins.prepare;\n            _prepare.register(this.addMovieClips);\n        }\n        _prepare.upload(displayObject, done);\n    }\n\n    /**\n     * Add movie clips to the upload prepare.\n     * @method PIXI.animate.utils.addMovieClips\n     * @static\n     * @private\n     * @param {*} item To add to the queue \n     */\n    static addMovieClips(item) {\n        if (item instanceof PIXI.animate.MovieClip) {\n            item._timedChildTimelines.forEach((timeline) => {\n                const index = item.children.indexOf(timeline.target);\n                if (index === -1) {\n                    _prepare.add(timeline.target);\n                }\n            });\n            return true;\n        }\n        return false;\n    }\n}","/**\n * Mixins for the PIXI.Container class.\n * @class Container\n * @memberof PIXI\n */\nconst p = PIXI.Container.prototype;\n\n/**\n * Shortcut for `addChild`.\n * @method PIXI.Container#ac\n * @param {*} [child*] N-number of children\n * @return {PIXI.DisplayObject} Instance of first child added\n */\np.ac = p.addChild;\n\n/**\n * Extend a container\n * @method PIXI.Container.extend\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.Container.e\n * @static\n * @param {PIXI.Container} child The child function\n * @return {PIXI.Container} THe child\n */\nPIXI.Container.extend = PIXI.Container.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","import utils from '../animate/utils';\n\n/**\n * Mixins for the PIXI.DisplayObject class.\n * @memberof PIXI\n * @class DisplayObject\n */\nconst p = PIXI.DisplayObject.prototype;\n\n// Color Matrix filter\nlet ColorMatrixFilter;\nif (PIXI.filters) {\n    ColorMatrixFilter = PIXI.filters.ColorMatrixFilter;\n}\n\n/**\n * Function to see if this is renderable or not. Useful for setting masks.\n * @method PIXI.DisplayObject#setRenderable\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\n/**\n * Shortcut to `setRenderable`.\n * @method PIXI.DisplayObject#re\n * @param  {Boolean} [renderable=false] Make renderable\n * @return {PIXI.DisplayObject}\n */\np.setRenderable = p.re = function(renderable) {\n    this.renderable = !!renderable;\n    return this;\n};\n\n/**\n * Shortcut for `setTransform`.\n * @method PIXI.DisplayObject#tr\n * @param {Number} x The X position\n * @param {Number} y The Y position\n * @param {Number} scaleX The X Scale value\n * @param {Number} scaleY The Y Scale value\n * @param {Number} skewX The X skew value\n * @param {Number} skewY The Y skew value\n * @param {Number} pivotX The X pivot value\n * @param {Number} pivotY The Y pivot value\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.t = p.setTransform;\n\n/**\n * Setter for mask to be able to chain.\n * @method PIXI.DisplayObject#setMask\n * @param {PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for `setMask`.\n * @method PIXI.DisplayObject#ma\n * @param {PIXI.Sprite|PIXI.Graphics} mask The mask shape to use\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setMask = p.ma = function(mask) {\n    // According to PIXI, only Graphics and Sprites can \n    // be used as mask, let's ignore everything else, like other\n    // movieclips and displayobjects/containers\n    if (mask) {\n        if (!(mask instanceof PIXI.Graphics) && !(mask instanceof PIXI.Sprite)) {\n            if (typeof console !== \"undefined\" && console.warn) {\n                console.warn(\"Warning: Masks can only be PIXI.Graphics or PIXI.Sprite objects.\");\n            }\n            return this;\n        }\n    }\n    this.mask = mask;\n    return this;\n};\n\n/**\n * Setter for the alpha\n * @method PIXI.DisplayObject#setAlpha\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\n/**\n * Shortcut for `setAlpha`.\n * @method PIXI.DisplayObject#a\n * @param {Number} alpha The alpha amount to use, from 0 to 1\n * @return {PIXI.DisplayObject} Instance for chaining\n */\np.setAlpha = p.a = function(alpha) {\n    this.alpha = alpha;\n    return this;\n};\n\n/**\n * Set the tint values by color.\n * @method PIXI.DisplayObject#setTint\n * @param {int} tint The color value to tint\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to `setTint`.\n * @method PIXI.DisplayObject#tn\n * @param {Number|String} tint The red percentage value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setTint = p.i = function(tint) {\n    if (typeof tint === \"string\") {\n        tint = utils.hexToUint(tint);\n    }\n    // this.tint = tint\n    // return this;\n    // TODO: Replace with DisplayObject.tint setter\n    // once the functionality is added to Pixi.js, for\n    // now we'll use the slower ColorMatrixFilter to handle\n    // the color transformation\n    var r = tint >> 16 & 0xFF;\n    var g = tint >> 8 & 0xFF;\n    var b = tint & 0xFF;\n    return this.c(r / 255, 0, g / 255, 0, b / 255, 0);\n};\n\n/**\n * Set additive and multiply color, tinting\n * @method PIXI.DisplayObject#setColorTransform\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\n/**\n * Shortcut to `setColor`.\n * @method PIXI.DisplayObject#c\n * @param {Number} r The multiply red value\n * @param {Number} rA The additive red value\n * @param {Number} g The multiply green value\n * @param {Number} gA The additive green value\n * @param {Number} b The multiply blue value\n * @param {Number} bA The additive blue value\n * @return {PIXI.DisplayObject} Object for chaining\n */\np.setColorTransform = p.c = function(r, rA, g, gA, b, bA) {\n    var filter = this.colorTransformFilter;\n    filter.matrix[0] = r;\n    filter.matrix[4] = rA;\n    filter.matrix[6] = g;\n    filter.matrix[9] = gA;\n    filter.matrix[12] = b;\n    filter.matrix[14] = bA;\n    this.filters = [filter];\n    return this;\n};\n\n/**\n * The current default color transforming filters\n * @name {PIXI.filters.ColorMatrixFilter} PIXI.DisplayObject#colorTransformFilter\n */\nif (!p.hasOwnProperty('colorTransformFilter')) {\n    Object.defineProperty(p, 'colorTransformFilter', {\n        set: function(filter) {\n            this._colorTransformFilter = filter;\n        },\n        get: function() {\n            return this._colorTransformFilter || new ColorMatrixFilter();\n        }\n    });\n}\n\n/**\n * Extend a container\n * @method PIXI.DisplayObject.extend\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.DisplayObject.e\n * @static\n * @param {PIXI.DisplayObject} child The child function\n * @return {PIXI.DisplayObject} THe child\n */\nPIXI.DisplayObject.extend = PIXI.DisplayObject.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","/**\n * Mixins for the PIXI.Graphics class.\n * @memberof PIXI\n * @class Graphics\n */\nconst p = PIXI.Graphics.prototype;\n\n/**\n * Shortcut for `drawCommands`.\n * @method PIXI.Graphics#d\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\n/**\n * Execute a series of commands, this is the name of the short function\n * followed by the parameters, e.g., `[\"f\", \"#ff0000\", \"r\", 0, 0, 100, 200]`\n * @method PIXI.Graphics#drawCommands\n * @param  {Array} commands The commands and parameters to draw\n * @return {PIXI.Graphics}\n */\np.drawCommands = p.d = function(commands) {\n    var currentCommand, params = [],\n        i = 0;\n\n    while (i <= commands.length) {\n        var item = commands[i++];\n        if (item === undefined || this[item]) {\n            if (currentCommand) {\n                this[currentCommand].apply(this, params);\n                params.length = 0;\n            }\n            currentCommand = item;\n        } else {\n            params.push(item);\n        }\n    }\n    return this;\n};\n\n/**\n * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified\n * since the fill or stroke was last set.\n * @method PIXI.Graphics#c\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.c = p.closePath;\n\n/**\n * Alias for `addHole`\n * @method PIXI.Graphics#h\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.h = p.addHole;\n\n/**\n * Shortcut to `moveTo`.\n * @method PIXI.Graphics#m\n * @param {Number} x The x coordinate the drawing point should move to.\n * @param {Number} y The y coordinate the drawing point should move to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls).\n **/\np.m = p.moveTo;\n\n/**\n * Shortcut to `lineTo`.\n * @method PIXI.Graphics#l\n * @param {Number} x The x coordinate the drawing point should draw to.\n * @param {Number} y The y coordinate the drawing point should draw to.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.l = p.lineTo;\n\n/**\n * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy). For detailed\n * information, read the <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\">\n * whatwg spec</a>. A tiny API method \"qt\" also exists.\n * @method PIXI.Graphics#q\n * @param {Number} cpx\n * @param {Number} cpy\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.q = p.quadraticCurveTo;\n\n/**\n * Shortcut to `bezierCurveTo`.\n * @method PIXI.Graphics#b\n * @param {Number} cp1x\n * @param {Number} cp1y\n * @param {Number} cp2x\n * @param {Number} cp2y\n * @param {Number} x\n * @param {Number} y\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.b = p.bezierCurveTo;\n\n/**\n * Shortcut to `beginFill`.\n * @method PIXI.Graphics#f\n * @param {Uint} color The hex color value (e.g. 0xFFFFFF)\n * null will result in no fill.\n * @param {Number} [alpha=1] The alpha value of fill\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.f = p.beginFill;\n\n/**\n * Shortcut to `lineStyle`.\n * @method PIXI.Graphics#s\n * @param {String} color A CSS compatible color value (ex. \"#FF0000\", \"red\", or \"rgba(255,0,0,0.5)\"). Setting to\n * null will result in no stroke.\n * @param {Number} [thickness=1] The thickness of the stroke\n * @param {Number} [alpha=1] The alpha value from 0 (invisibile) to 1 (visible)\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.s = p.lineStyle;\n\n/**\n * Shortcut to `drawRect`.\n * @method PIXI.Graphics#dr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\n/**\n * Shortcut to `drawRect`.\n * @method PIXI.Graphics#r\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dr = p.drawRect;\n\n/**\n * Shortcut to `drawRoundedRect`.\n * @method PIXI.Graphics#rr\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radius The corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rr = p.drawRoundedRect;\n\n/**\n * Shortcut to `drawRoundedRect`.\n * @method PIXI.Graphics#rc\n * @param {Number} x\n * @param {Number} y\n * @param {Number} w Width of the rectangle\n * @param {Number} h Height of the rectangle\n * @param {Number} radiusTL The top left corner radius\n * @param {Number} radiusTR The top right corner radius\n * @param {Number} radiusBR The bottom right corner radius\n * @param {Number} radiusBL The bottom left corner radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rc = p.drawRoundedRect;\n\n/**\n * Shortcut to `drawCircle`.\n * @method PIXI.Graphics#dc\n * @param {Number} x x coordinate center point of circle.\n * @param {Number} y y coordinate center point of circle.\n * @param {Number} radius Radius of circle.\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.dc = p.drawCircle;\n\n/**\n * Shortcut to `arc`.\n * @method PIXI.Graphics#ac\n * @param {Number} x\n * @param {Number} y\n * @param {Number} radius\n * @param {Number} startAngle Measured in radians.\n * @param {Number} endAngle Measured in radians.\n * @param {Boolean} anticlockwise\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ar = p.arc;\n\n/**\n * Shortcut to `arcTo`.\n * @method PIXI.Graphics#at\n * @param {Number} x1\n * @param {Number} y1\n * @param {Number} x2\n * @param {Number} y2\n * @param {Number} radius\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.at = p.arcTo;\n\n/**\n * Shortcut to `drawEllipse`.\n * @method  PIXI.Graphics#de\n * @param  {Number} x      [description]\n * @param  {Number} y      [description]\n * @param  {Number} width  [description]\n * @param  {Number} height [description]\n */\np.de = p.drawEllipse;\n\n/**\n * Placeholder method for a linear fill. Pixi does not support linear fills,\n * so we just pick the first color in colorArray\n * @method PIXI.Graphics#lf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.lf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Linear gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a radial fill. Pixi does not support radial fills,\n * so we just pick the first color in colorArray\n * @method PIXI.Graphics#rf\n * @param {Array} colorArray An array of CSS compatible color values @see `f`\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rf = function(colorArray) {\n    // @if DEBUG\n    console.warn(\"Radial gradient fills are not supported\");\n    // @endif\n    return this.f(colorArray[0]);\n};\n\n/**\n * Placeholder method for a `beginBitmapFill`. Pixi does not support bitmap fills.\n * @method PIXI.Graphics#bf\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bf = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap fills are not supported\");\n    // @endif\n    return this.f(0x0);\n};\n\n/**\n * Placeholder method for a `setStrokeDash`. Pixi does not support dashed strokes.\n * @method PIXI.Graphics#sd\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.sd = function() {\n    // @if DEBUG\n    console.warn(\"Dashed strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginBitmapStroke`. Pixi does not support bitmap strokes.\n * @method PIXI.Graphics#bs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.bs = function() {\n    // @if DEBUG\n    console.warn(\"Bitmap strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginLinearGradientStroke`. Pixi does not support gradient strokes.\n * @method PIXI.Graphics#ls\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.ls = function() {\n    // @if DEBUG\n    console.warn(\"Linear gradient strokes are not supported\");\n    // @endif\n    return this;\n};\n\n/**\n * Placeholder method for a `beginRadialGradientStroke`. Pixi does not support gradient strokes.\n * @method PIXI.Graphics#rs\n * @return {PIXI.Graphics} The Graphics instance the method is called on (useful for chaining calls.)\n **/\np.rs = function() {\n    // @if DEBUG\n    console.warn(\"Radial gradient strokes are not supported\");\n    // @endif\n    return this;\n};","/**\n * Mixins for the PIXI.Sprite class.\n * @memberof PIXI\n * @class Sprite\n */\nconst p = PIXI.Sprite.prototype;\n\n/**\n * Extend a container\n * @method PIXI.Sprite.extend\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\n/**\n * Extend a container (shortcut for `extend`)\n * @method PIXI.Sprite.e\n * @static\n * @param {PIXI.Sprite} child The child function\n * @return {PIXI.Sprite} THe child\n */\nPIXI.Sprite.extend = PIXI.Sprite.e = function(child) {\n    child.prototype = Object.create(p);\n    child.prototype.__parent = p;\n    child.prototype.constructor = child;\n    return child;\n};","/**\n * Mixins for the PIXI.Text class.\n * @memberof PIXI\n * @class Text\n */\nconst p = PIXI.Text.prototype;\n\n// Possible align values\nconst ALIGN_VALUES = [\"center\", \"right\"];\n\n/**\n * Setter for the alignment, also sets the anchor point\n * to make sure the positioning is correct.\n * @method PIXI.Text#setAlign\n * @param {String} align Either, center, right, left\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for `setAlign`.\n * @method PIXI.Text#g\n * @param {String|int} align Either, center (0), right (1), left (-1)\n * @return {PIXI.Text} For chaining\n */\np.setAlign = p.g = function(align) {\n    if (typeof align == \"string\") {\n        align = ALIGN_VALUES.indexOf(align);\n    }\n    this.style.align = ALIGN_VALUES[align] || \"left\";\n    this.anchor.x = (align + 1) / 2;\n    return this;\n};\n\n// Map of short names to long names\nvar STYLE_PROPS = {\n    o: 'font', // TODO: deprecate in Pixi v4\n    z: 'fontSize',\n    f: 'fontFamily',\n    y: 'fontStyle',\n    g: 'fontWeight',\n    i: 'fill',\n    a: 'align',\n    s: 'stroke',\n    t: 'strokeThickness',\n    w: 'wordWrap',\n    d: 'wordWrapWidth',\n    l: 'lineHeight',\n    h: 'dropShadow',\n    c: 'dropShadowColor',\n    n: 'dropShadowAngle',\n    b: 'dropShadowBlur',\n    p: 'padding',\n    x: 'textBaseline',\n    j: 'lineJoin',\n    m: 'miterLimit',\n    e: 'letterSpacing'\n};\n\n/**\n * Set the style, a chainable version of style setter\n * @method PIXI.Text#setStyle\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\n/**\n * Shortcut for `setStyle`.\n * @method PIXI.Text#ss\n * @param {Object} style\n * @return {PIXI.Text} instance of text field\n */\np.setStyle = p.ss = function(style) {\n    // Replace short STYLE_PROPS with long names\n    for (var k in STYLE_PROPS) {\n        if (style[k] !== undefined) {\n            style[STYLE_PROPS[k]] = style[k];\n            delete style[k];\n        }\n    }\n    this.style = style;\n    return this;\n};\n\n/**\n * Initial setting of the drop shadow.\n * @method PIXI.Text#setShadow\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\n/**\n * Shortcut for `setShadow`.\n * @method PIXI.Text#sh\n * @param {String} [color=\"#000000\"] The color to set\n * @param {Number} [angle=Math.PI/4] The angle of offset, in radians\n * @param {Number} [distance=5] The offset distance\n * @return {PIXI.Text} For chaining\n */\np.setShadow = p.sh = function(color, angle, distance) {\n    var style = this.style;\n    style.dropShadow = true;\n\n    // Convert color to hex string\n    if (color !== undefined) {\n        color = \"#\" + color.toString(16);\n    }\n    style.dropShadowColor = isUndefinedOr(color, style.dropShadowColor);\n    style.dropShadowAngle = isUndefinedOr(angle, style.dropShadowAngle);\n    style.dropShadowDistance = isUndefinedOr(distance, style.dropShadowDistance);\n    return this;\n};\n\n/**\n * Check if a value is undefined, fallback to default value\n * @method isUndefinedOr\n * @private\n * @param {*} value The value to check\n * @param {*} defaultValue The default value if value is undefined\n * @return {*} The either the value or the default value\n */\nvar isUndefinedOr = function(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n};\n","import Container from './Container';\nimport DisplayObject from './DisplayObject';\nimport Sprite from './Sprite';\nimport Graphics from './Graphics';\nimport Text from './Text';\n\n/**\n * @namespace PIXI\n */\nexport default {\n    Container,\n    DisplayObject,\n    Sprite,\n    Graphics,\n    Text\n};","// If we're in the browser make sure PIXI is available\nif (typeof PIXI === 'undefined') {\n    throw \"Requires PIXI\";\n}\n\nif (!PIXI.animate) {\n    // Include the PIXI mixins\n    require('./mixins');\n\n    // Add to the PIXI global object\n    Object.defineProperty(PIXI, 'animate', {\n        enumerable: true,\n        get() { return require('./animate'); }\n    });\n}\n\n// Export for Node-compatible environments like Electron\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = PIXI.animate;\n}\n"],"sourceRoot":"."}